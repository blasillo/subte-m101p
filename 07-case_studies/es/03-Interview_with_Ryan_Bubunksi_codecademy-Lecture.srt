1
00:00:00,000 --> 00:00:00,630

2
00:00:00,630 --> 00:00:02,230
Bienvenido de regreso a M101.

3
00:00:02,230 --> 00:00:05,170
Estoy acá con Ryan Bubinski
cofundador técnico de

4
00:00:05,170 --> 00:00:06,330
Codecademy.

5
00:00:06,330 --> 00:00:08,710
Está con nosotros hoy
para hablar sobre su

6
00:00:08,710 --> 00:00:10,220
uso de MongoDB.

7
00:00:10,220 --> 00:00:12,260
Gracias por venir, Ryan.

8
00:00:12,260 --> 00:00:12,750
Gracias, Andrew.

9
00:00:12,750 --> 00:00:14,192
Es un placer.

10
00:00:14,192 --> 00:00:14,860
Muy bien.

11
00:00:14,860 --> 00:00:16,950
Primero cuéntanos un poco
sobre lo que Codecademy

12
00:00:16,950 --> 00:00:18,890
hace.

13
00:00:18,890 --> 00:00:20,840
Muchos de nuestros oyentes
son de Europa Oriental así

14
00:00:20,840 --> 00:00:23,040
que quizás algunos
no lo conocen.

15
00:00:23,040 --> 00:00:23,780
Por supuesto.

16
00:00:23,780 --> 00:00:27,660
Codecademy es la manera más fácil
de aprender a desarrollar en línea.

17
00:00:27,660 --> 00:00:30,240
Contiene un serie de cursos
interactivos, tutoriales, tanto

18
00:00:30,240 --> 00:00:33,020
para principiantes como para
alguien competente y conocedor

19
00:00:33,020 --> 00:00:35,880
de tecnologías de
programación y desarrollo.

20
00:00:35,880 --> 00:00:36,650
Muy bien.

21
00:00:36,650 --> 00:00:38,180
Y es algo diferente a
la manera en que hemos

22
00:00:38,180 --> 00:00:41,040
estructurado este curso,
porque en lugar de segmentos

23
00:00:41,040 --> 00:00:43,476
de vídeo seguidos por pequeños
cuestionarios, es más un

24
00:00:43,476 --> 00:00:46,650
sistema interactivo
donde lees un poco 

25
00:00:46,650 --> 00:00:51,090
y luego haces una tarea que te
permita mostrar inmediatamente

26
00:00:51,090 --> 00:00:53,620
que tienes la habilidad de
hacer lo que aprendiste. ¿No?

27
00:00:53,620 --> 00:00:53,860
Sí.

28
00:00:53,860 --> 00:00:54,360
Es correcto.

29
00:00:54,360 --> 00:00:57,230
Nosotros optamos por el método
de aprender haciendo.

30
00:00:57,230 --> 00:01:00,830
Así que tratamos que nuestros
estudiantes empiecen a escribir

31
00:01:00,830 --> 00:01:04,170
código lo más rápido posible y
les explicamos qué está ocurriendo

32
00:01:04,170 --> 00:01:06,950
mientras que desarrollan,
mostrándoles cómo pueden

33
00:01:06,950 --> 00:01:10,310
aplicar la programación para
crear proyectos, páginas

34
00:01:10,310 --> 00:01:14,140
web y aplicaciones y en
verdad para hacer lo que

35
00:01:14,140 --> 00:01:16,420
sea que quieran hacer
con la programación.

36
00:01:16,420 --> 00:01:19,830
Y algunas de los primeros cursos que
ofrecieron fueron en JavaScript,

37
00:01:19,830 --> 00:01:20,460
¿no?

38
00:01:20,460 --> 00:01:22,200
Nuestro primer curso
fue en JavaScript.

39
00:01:22,200 --> 00:01:23,190
Así que es basado
completamente en la web.

40
00:01:23,190 --> 00:01:24,790
Todo dentro del navegador.

41
00:01:24,790 --> 00:01:28,460
Y como JavaScript es el
lenguaje de la web, también

42
00:01:28,460 --> 00:01:31,250
es el lenguaje de
los navegadores.

43
00:01:31,250 --> 00:01:35,760
Queríamos comenzar con algo
que era inmediatamente

44
00:01:35,760 --> 00:01:38,300
accesible para la mayoría de
la gente y que les permita

45
00:01:38,300 --> 00:01:41,360
comenzar inmediatamente a
crear aplicaciones web

46
00:01:41,360 --> 00:01:42,000
interesantes.

47
00:01:42,000 --> 00:01:44,160
Para nosotros, tenía
que ser JavaScript.

48
00:01:44,160 --> 00:01:46,020
Y ha sido bien popular, ¿no?

49
00:01:46,020 --> 00:01:48,865
¿Y han tenido millones de personas
que han hecho las lecciones y

50
00:01:48,865 --> 00:01:51,410
seguido adelente y
tomado los cursos?

51
00:01:51,410 --> 00:01:51,680
Sí.

52
00:01:51,680 --> 00:01:54,240
Creo que nuestro método ha
sido bien recibido por un

53
00:01:54,240 --> 00:01:57,670
gran número de personas alrededor
del mundo, con una gran variedad de

54
00:01:57,670 --> 00:02:02,320
intereses y creo que hemos,
afortunadamente, introducido

55
00:02:02,320 --> 00:02:04,130
a la programación a mucha
gente que de lo contrario

56
00:02:04,130 --> 00:02:07,000
nunca hubiesen estado interesados
en la programación o no se hubiesen

57
00:02:07,000 --> 00:02:08,789
involucrado con la programación.
Hemos logrado que estén interesados

58
00:02:08,789 --> 00:02:12,440
en esta arte y hemos
logrado que código

59
00:02:12,440 --> 00:02:15,090
sea algo normal, lo cual
es lo que queremos hacer.

60
00:02:15,090 --> 00:02:16,360
Es bastante interesante.

61
00:02:16,360 --> 00:02:19,650
Así que comenzaron con MongoDB.

62
00:02:19,650 --> 00:02:21,380
¿Cómo así decidieron usar MongoDB? 

63
00:02:21,380 --> 00:02:23,490
¿Qué cosas de MongoDB 
les pareció interesantes

64
00:02:23,490 --> 00:02:24,870
a ustedes?

65
00:02:24,870 --> 00:02:25,370
Claro.

66
00:02:25,370 --> 00:02:28,050
Ésa es una larga historia.

67
00:02:28,050 --> 00:02:30,030
Entraremos en algunos
de los detalles, pero

68
00:02:30,030 --> 00:02:35,390
la versión corta es que
cuando recién estábamos

69
00:02:35,390 --> 00:02:38,280
comenzando, Zach y yo,
mi cofundador, estábamos

70
00:02:38,280 --> 00:02:40,430
haciendo prototipos de
diferentes versiones del sitio.

71
00:02:40,430 --> 00:02:44,150
Estábamos analizando las
diferentes maneras en las que

72
00:02:44,150 --> 00:02:47,450
podíamos crear una plataforma
interactiva en línea y frecuentemente

73
00:02:47,450 --> 00:02:49,870
cambiábamos las definiciones de
nuestro modelo, de nuestro esquema,

74
00:02:49,870 --> 00:02:51,830
las definiciones y las
relaciones y los modelos.

75
00:02:51,830 --> 00:02:55,610
Y queríamos un almacén de datos
que sea muy flexible y que no

76
00:02:55,610 --> 00:02:59,080
nos detenga cuando
hagamos estos cambios de

77
00:02:59,080 --> 00:03:00,520
de definiciones.

78
00:03:00,520 --> 00:03:03,460
Yo en verdad no conocía
mucho sobre Mongo.

79
00:03:03,460 --> 00:03:07,850
Por muchos años antes fui un
hombre de base de datos relacional

80
00:03:07,850 --> 00:03:12,930
Y consideré Mongo como esta
tecnología fantástica que nos

81
00:03:12,930 --> 00:03:16,800
permitiría no preocuparnos
sobre esquema a priori--

82
00:03:16,800 --> 00:03:18,860
o por lo menos hasta
que en verdad pensemos 

83
00:03:18,860 --> 00:03:20,860
seriamente sobre escalar.

84
00:03:20,860 --> 00:03:24,000
Entonces para nosotros, MongoDB
era la manera más rápida de

85
00:03:24,000 --> 00:03:27,430
hacer prototipos de
diferentes modelos y sus

86
00:03:27,430 --> 00:03:29,280
relaciones de una manera u otra.

87
00:03:29,280 --> 00:03:33,140
Y sentí que eso aceleraba
significativamente el

88
00:03:33,140 --> 00:03:34,750
desarrollo para nosotros.

89
00:03:34,750 --> 00:03:38,310
¿Tuviste algunas preocupaciones
cuando empezaste a usar Mongo?

90
00:03:38,310 --> 00:03:39,555
Si vienes del mundo
relacional, ¿qué sería

91
00:03:39,555 --> 00:03:41,180
lo que más te preocuparía?

92
00:03:41,180 --> 00:03:44,710
Naturalmente, hacer joins
a través de diferentes modelos

93
00:03:44,710 --> 00:03:48,390
y diferentes tablas, o en el
caso de MongoDB, colecciones.

94
00:03:48,390 --> 00:03:54,350
Yo creo que en el mundo de
bases de datos relacionales,

95
00:03:54,350 --> 00:03:57,280
tu intuición o tu instinto
siempre te dice que

96
00:03:57,280 --> 00:04:01,440
normalices, normalices, normalices,
y en almacenes de documentos o

97
00:04:01,440 --> 00:04:05,760
de clave/valor, tienes que
de-normalizar a veces y

98
00:04:05,760 --> 00:04:07,030
a veces eso no te
parece que está bien.

99
00:04:07,030 --> 00:04:11,530
Pero en muchos casos, puedes encontrar
un balance óptimo donde obtienes lo

100
00:04:11,530 --> 00:04:15,280
lo mejor de los dos mundos, lo cual
lo hace mucho más fácil de manejar.

101
00:04:15,280 --> 00:04:18,079
Sí.

102
00:04:18,079 --> 00:04:21,820
¿Cuál es su lenguaje de
implementación para Codecademy? 

103
00:04:21,820 --> 00:04:22,120
Claro.

104
00:04:22,120 --> 00:04:25,770
Codecademy está construido
principalmente sobre Ruby

105
00:04:25,770 --> 00:04:29,250
para cualquier cosa del lado
del servidor y JavaScript para

106
00:04:29,250 --> 00:04:31,330
algo de lógica del lado
del servidor y toda la

107
00:04:31,330 --> 00:04:32,780
lógica del lado de
cliente, por supuesto.

108
00:04:32,780 --> 00:04:37,720
Y tenemos múltiples capas
afuera de MongoDB.

109
00:04:37,720 --> 00:04:40,090
Nuestra capa de API está
implementada en Ruby.

110
00:04:40,090 --> 00:04:42,290
Nuestra capa de aplicación
está implementada en Ruby y

111
00:04:42,290 --> 00:04:43,140
en JavaScript.

112
00:04:43,140 --> 00:04:46,920
Y tenemos una serie de
aplicaciones JavaScript

113
00:04:46,920 --> 00:04:51,210
independientes que corren el
cliente web o la aplicación

114
00:04:51,210 --> 00:04:54,080
web en sí que mucha gente
conoce como Codecademy.

115
00:04:54,080 --> 00:04:55,120
Comprendo.

116
00:04:55,120 --> 00:04:58,150
¿Y usan nuestros drivers
directamente o algo

117
00:04:58,150 --> 00:04:59,420
intermediario, como alguna

118
00:04:59,420 --> 00:05:01,450
capa de relación que
se comunica con MongoDB?

119
00:05:01,450 --> 00:05:09,800
Para nuestra API que envuelve
nuestro capa de datos, usamos

120
00:05:09,800 --> 00:05:14,290
un cartógrafo de documento a
objecto (ODM) llamado Mongoid,

121
00:05:14,290 --> 00:05:18,270
usa su propia versión de un driver que
de MongoDB que se comunica directamente

122
00:05:18,270 --> 00:05:19,140
con nuestra base de datos.

123
00:05:19,140 --> 00:05:22,440
Y hemos experimentado con
usar el driver directamente.

124
00:05:22,440 --> 00:05:25,830
En algunos casos lo usamos,
si queremos que un "insert" o

125
00:05:25,830 --> 00:05:29,890
"update" muy particular
vaya directo al almacen

126
00:05:29,890 --> 00:05:31,680
de datos y siga adelante.

127
00:05:31,680 --> 00:05:37,630
Pero para la mayoría de desarrollo
usar un ODM es una buena manera de

128
00:05:37,630 --> 00:05:41,470
encapsular la lógica y enfocarse
desde un nivel más alto en cómo

129
00:05:41,470 --> 00:05:45,560
está estructurado el modelo,
cómo se relaciona a los otros

130
00:05:45,560 --> 00:05:48,390
modelos, y eso nos permite
conceptualizar más fácilmente

131
00:05:48,390 --> 00:05:52,740
cómo estamos diseñando
la capa de datos.

132
00:05:52,740 --> 00:05:56,910
Así que excepto en lo casos
excepcionales donde tenemos que

133
00:05:56,910 --> 00:06:00,700
optimizar el rendimiento o en un caso
de uso en particular, usamos un ODM.

134
00:06:00,700 --> 00:06:00,920
Claro.

135
00:06:00,920 --> 00:06:02,010
Esa es mi pregunta.

136
00:06:02,010 --> 00:06:05,610
Estas capas de relación, a veces
lo que hacen es hacer que el

137
00:06:05,610 --> 00:06:08,750
desarrollador esté un poco
más lejos del esquema.

138
00:06:08,750 --> 00:06:11,990
Y para obtener buen rendimiento en
cualquier sistema con base de datos

139
00:06:11,990 --> 00:06:13,430
hay que asegurarse que
estés usando los índices.

140
00:06:13,430 --> 00:06:14,100
Sí.

141
00:06:14,100 --> 00:06:16,590
¿Es un problema?

142
00:06:16,590 --> 00:06:18,450
Tal vez si tienes un equipo
pequeño es un gran problema,

143
00:06:18,450 --> 00:06:21,750
pero hacer que todos sepan
cómo escribir código que va

144
00:06:21,750 --> 00:06:23,190
a utilizar los índices
si estás usando esta capa

145
00:06:23,190 --> 00:06:24,780
de relación o,

146
00:06:24,780 --> 00:06:26,970
¿cuáles son los beneficios? ¿Cuáles
son los pros y los contras de eso?

147
00:06:26,970 --> 00:06:27,390
Sí.

148
00:06:27,390 --> 00:06:30,240
Creo que cuando estás escogiendo
si es que vas a usar el driver o

149
00:06:30,240 --> 00:06:35,070
un ODM, entonces tienes que
considerar cuántos desarrolladores

150
00:06:35,070 --> 00:06:36,730
hay, como mencionaste.

151
00:06:36,730 --> 00:06:39,235
Qué tan familiarizados están
con tu almacén de datos.

152
00:06:39,235 --> 00:06:42,170

153
00:06:42,170 --> 00:06:45,510
Algunos de los pros de un ODM
son, por supuesto, encapsulación

154
00:06:45,510 --> 00:06:47,700
de la lógica.

155
00:06:47,700 --> 00:06:50,890
En particular para la infraestructura
Rails--la cual no usamos para la API

156
00:06:50,890 --> 00:06:53,890
pero si para la capa
de la aplicación--

157
00:06:53,890 --> 00:06:57,740
nuestra API es esencialmente
una aplicación Rack.

158
00:06:57,740 --> 00:07:00,210
Entonces hay muy poca
convención sobre lo que

159
00:07:00,210 --> 00:07:00,720
estás construyendo.

160
00:07:00,720 --> 00:07:00,930
¿Rack?

161
00:07:00,930 --> 00:07:05,870
Rack es esencialmente una API HTTP.

162
00:07:05,870 --> 00:07:10,740
Es una infraestructura básica
sobre Ruby que te da una buena

163
00:07:10,740 --> 00:07:16,630
interfaz para manejar peticiones
y respuestas HTTP.

164
00:07:16,630 --> 00:07:22,090
Es básicamente lo que
maneja la interfaz del

165
00:07:22,090 --> 00:07:23,410
servidor web de Rails.

166
00:07:23,410 --> 00:07:27,200
Rails va sobre Rack
como infraestructura.

167
00:07:27,200 --> 00:07:30,480
Así que Rails es una
infraestructura sobre otra.

168
00:07:30,480 --> 00:07:33,690
Y Rails tiene muchas cosas
que no necesariamente quieres

169
00:07:33,690 --> 00:07:37,300
en una API, pero sí en
una aplicación web.

170
00:07:37,300 --> 00:07:40,950
Entonces en una API, donde quiere
optimizar tiempo de respuesta y

171
00:07:40,950 --> 00:07:46,010
disponibilidad, vas a querer
llegar al nivel del servidor

172
00:07:46,010 --> 00:07:50,790
web--es decir, en nuestro
caso usamos Nginx--

173
00:07:50,790 --> 00:07:52,720
quieres llegar al
ciclo de petición

174
00:07:52,720 --> 00:07:54,460
respuesta lo más rápido posible.

175
00:07:54,460 --> 00:07:55,810
Así como tú mencionas que
a veces cuando estás

176
00:07:55,810 --> 00:07:57,540
optimizando para tu capa
de datos, quiere estar

177
00:07:57,540 --> 00:08:00,710
lo más cerca posible
del almacén de datos.

178
00:08:00,710 --> 00:08:06,100
Así que para reiterar, algo como
la infraestructura Rails o una

179
00:08:06,100 --> 00:08:08,243
infraestructura de desarrollo web,
vas a querer encapsular mucho de

180
00:08:08,243 --> 00:08:08,660
esa lógica.

181
00:08:08,660 --> 00:08:11,370
Y quieres optimizar a un nivel
de estructura más alto.

182
00:08:11,370 --> 00:08:13,330
Quieres asegurarte que los
documentos tengan lo campos

183
00:08:13,330 --> 00:08:15,890
que necesitan y que las
relaciones están bien hechas.

184
00:08:15,890 --> 00:08:20,030
Y a veces, si estás lidiando
exclusivamente con un driver,

185
00:08:20,030 --> 00:08:23,690
el manejar propiedades de
modelos, el manejar modelos

186
00:08:23,690 --> 00:08:27,140
de relaciones puede ser tedioso.

187
00:08:27,140 --> 00:08:29,790
Cuando estás desarrollando rápido
y las cosas evolucionan rápido,

188
00:08:29,790 --> 00:08:34,289
cuando tu estructura comienza
a convergir y quieres comenzar

189
00:08:34,289 --> 00:08:37,710
a optimizar y comienzas a
considerar los tiempos de

190
00:08:37,710 --> 00:08:40,630
consultas, escrituras y
comienzas a tener una carga

191
00:08:40,630 --> 00:08:45,000
significativa que en verdad presiona
tu capa de datos, ahí es cuando

192
00:08:45,000 --> 00:08:49,230
tienes que comenzar, como equipo
por supuesto, a enfocarte en el

193
00:08:49,230 --> 00:08:50,645
porcentaje del uso de los índices.

194
00:08:50,645 --> 00:08:50,990
Claro.

195
00:08:50,990 --> 00:08:52,910
Si no estás dándole a los
índices, ¿qué tan grande

196
00:08:52,910 --> 00:08:53,770
es la colección?

197
00:08:53,770 --> 00:08:55,500
¿Hay un problema
serio de rendimiento?

198
00:08:55,500 --> 00:08:57,130
Y luego comenzar a
evaluar por comparación

199
00:08:57,130 --> 00:09:01,540
Así que hemos optado por asegurarnos que
todos en el equipo estén familiarizados,

200
00:09:01,540 --> 00:09:04,690
por supuesto, con la pila completa.
Que la gente esté familiarizada con

201
00:09:04,690 --> 00:09:06,575
los drivers que usamos.

202
00:09:06,575 --> 00:09:09,770
No todos trabajan directamente
con el driver, especialmente si

203
00:09:09,770 --> 00:09:11,760
eres un ingeniero del "front end" y
estás incursionando en el "back end".

204
00:09:11,760 --> 00:09:14,875
Probablemente vas a interactuar
más con nuestro ODM o nuestro

205
00:09:14,875 --> 00:09:17,870
cartógrafo y menos con el driver.

206
00:09:17,870 --> 00:09:21,650
Aún así, hemos configurado
una serie de herramientas--

207
00:09:21,650 --> 00:09:24,050
tanto algunas que hemos
construido como otras que

208
00:09:24,050 --> 00:09:26,340
están disponibles públicamente--

209
00:09:26,340 --> 00:09:31,050
para alertar a los desarrolladores
si es que han obviado un índice en

210
00:09:31,050 --> 00:09:34,570
una colección grande o si han
escrito una consulta que no va

211
00:09:34,570 --> 00:09:40,050
a tener buen rendimiento
en producción o si simplemente

212
00:09:40,050 --> 00:09:40,610
escribieron una--

213
00:09:40,610 --> 00:09:42,890
No sé si han abarcado
consultas de n+1 o

214
00:09:42,890 --> 00:09:44,930
consultas que resultan en
esencialmente un gran número

215
00:09:44,930 --> 00:09:46,530
peticiones a la base
de datos en una sola

216
00:09:46,530 --> 00:09:48,990
petición de página web.

217
00:09:48,990 --> 00:09:49,280
Claro.

218
00:09:49,280 --> 00:09:52,220
Todas esas cosas son muy
peligrosas cuando se pasan

219
00:09:52,220 --> 00:09:53,860
a producción, así que
tratamos de atraparlas

220
00:09:53,860 --> 00:09:55,435
en desarrollo, por supuesto.

221
00:09:55,435 --> 00:09:59,270
Hemos abarcado el mirar
a los planes de consulta

222
00:09:59,270 --> 00:10:02,135
y el perfilador.

223
00:10:02,135 --> 00:10:03,190
¿Ustedes usan eso?

224
00:10:03,190 --> 00:10:04,980
¿Tratan de tomar nota
de consultas largas?

225
00:10:04,980 --> 00:10:07,150
¿Monitorean eso frecuentemente?

226
00:10:07,150 --> 00:10:14,220
Usamos el servicio MMS de 10gen
por si esencialmente algo

227
00:10:14,220 --> 00:10:15,720
no funciona bien.

228
00:10:15,720 --> 00:10:17,930
Es como hacer un análisis
de "qué pasó" y simplemente

229
00:10:17,930 --> 00:10:18,840
ver los logs.

230
00:10:18,840 --> 00:10:21,270
Ejecutamos el perfilador una
fracción del tiempo o en

231
00:10:21,270 --> 00:10:22,440
ciertos despliegues.

232
00:10:22,440 --> 00:10:23,650
No siempre, debido al
problema de rendimiento

233
00:10:23,650 --> 00:10:24,620
que sufres.

234
00:10:24,620 --> 00:10:26,450
Claro.

235
00:10:26,450 --> 00:10:31,150
Pero tratamos de mirar los logs
de la aplicación durante el

236
00:10:31,150 --> 00:10:32,430
desarrollo.

237
00:10:32,430 --> 00:10:33,850
Habilitamos, por supuesto,
los logs en desarrollo

238
00:10:33,850 --> 00:10:35,990
para nuestro driver.

239
00:10:35,990 --> 00:10:37,820
Simplemente cuenta el número
de consultas que estás haciendo

240
00:10:37,820 --> 00:10:39,560
en una petición.

241
00:10:39,560 --> 00:10:42,040
Hay muchos tipos de metas
holísticas que deberías

242
00:10:42,040 --> 00:10:44,210
intentar lograr cuando
creas aplicaciones web.

243
00:10:44,210 --> 00:10:45,380
Toca la base de datos
lo menos posible.

244
00:10:45,380 --> 00:10:45,660
Claro.

245
00:10:45,660 --> 00:10:48,650
No quieres tener que hacer 200
consultas a tu base de datos en

246
00:10:48,650 --> 00:10:49,220
una simple petición web.

247
00:10:49,220 --> 00:10:50,825
No importa si es que duran
una sola milésima de segundo.

248
00:10:50,825 --> 00:10:53,630
La latencia de la
petición aun te va

249
00:10:53,630 --> 00:10:54,670
a afectar fuertemente.

250
00:10:54,670 --> 00:10:58,030
Así que simplemente para asegurarnos
que cosas simples como esa, que

251
00:10:58,030 --> 00:11:00,800
un cartógrafo puede, a veces,
implementar ingenuamente--

252
00:11:00,800 --> 00:11:02,830
Sí.

253
00:11:02,830 --> 00:11:06,375
--lo suficiente para ser peligroso
o no saber exactamente cómo está

254
00:11:06,375 --> 00:11:10,550
ejecutando el plan de consulta,
puedes encontrarte en unas de

255
00:11:10,550 --> 00:11:13,640
esas situaciones muy peligrosas
para ambientes en producción.

256
00:11:13,640 --> 00:11:15,760
¿Usan alguna capa de cache
en frente de Mongo?

257
00:11:15,760 --> 00:11:17,200
¿Como Memcached o
algo por el estilo?

258
00:11:17,200 --> 00:11:18,340
Hemos pensado en ello.

259
00:11:18,340 --> 00:11:19,350
No hemos necesitado hacerlo.

260
00:11:19,350 --> 00:11:20,040
Eso es excelente.

261
00:11:20,040 --> 00:11:23,190
Creo que uno de los principios
de Mongo es que tus datos activos

262
00:11:23,190 --> 00:11:25,020
están en memoria.

263
00:11:25,020 --> 00:11:30,050
Así que hemos tenido la filosofía
básica de que si no está rindiendo

264
00:11:30,050 --> 00:11:32,720
en la capa de Mongo, entonces

265
00:11:32,720 --> 00:11:34,510
no lo estamos haciendo bien.

266
00:11:34,510 --> 00:11:37,080
Eso nos ha llevado muy lejos.

267
00:11:37,080 --> 00:11:39,290
No hemos configurado una capa
de cache intermediario en

268
00:11:39,290 --> 00:11:40,530
producción.

269
00:11:40,530 --> 00:11:44,460
Y en términos de manejo de
sesiones de los usuarios, los

270
00:11:44,460 --> 00:11:46,510
servidores web en sí, los
servidores de aplicación,

271
00:11:46,510 --> 00:11:48,680
¿no tiene estado?

272
00:11:48,680 --> 00:11:50,830
Entre interacciones,
mientras el usuario  

273
00:11:50,830 --> 00:11:53,760
interactúa con la página web,
¿recuperas el estado de Mongo

274
00:11:53,760 --> 00:11:57,400
para averiguar dónde le dejaste
o hay algún tipo de asociación

275
00:11:57,400 --> 00:11:59,170
entre el usuario y la
capa de la aplicación?

276
00:11:59,170 --> 00:11:59,670
Por supuesto.

277
00:11:59,670 --> 00:12:00,610
Cuéntame sobre eso.

278
00:12:00,610 --> 00:12:04,640
Así que tenemos una aplicación
web escalada horizontalmente,

279
00:12:04,640 --> 00:12:07,150
es decir que tenemos varios
servidores web.

280
00:12:07,150 --> 00:12:10,070
Y cuando una persona va a la
página web, pueden obtener

281
00:12:10,070 --> 00:12:10,630
cualquiera de estos servidores.

282
00:12:10,630 --> 00:12:11,060
Exactamente.

283
00:12:11,060 --> 00:12:13,910
Lo que requiere que por lo menos
estos mismos servidores no tengan

284
00:12:13,910 --> 00:12:18,820
estado, o no tengan ningún
conocimiento interno sobre

285
00:12:18,820 --> 00:12:19,770
el usuario.

286
00:12:19,770 --> 00:12:21,220
Claro.

287
00:12:21,220 --> 00:12:25,350
Cada usuario tiene una sesión
y usamos un almacén de datos

288
00:12:25,350 --> 00:12:26,310
basado en cookies para los usuarios.

289
00:12:26,310 --> 00:12:29,710
Así que cuando un usuario va
al sitio, les damos un ID único.

290
00:12:29,710 --> 00:12:32,780
Ese ID único se relaciona a un
documento en nuestra colección

291
00:12:32,780 --> 00:12:36,370
de usuarios y también es
almacenado localmente en el

292
00:12:36,370 --> 00:12:39,680
navegador del usuario en una cookie
que almacena su ID de usuario.

293
00:12:39,680 --> 00:12:43,090
Esa cookie es esencialmente
enviada a cualquiera que sea

294
00:12:43,090 --> 00:12:44,340
el servidor web que reciben.

295
00:12:44,340 --> 00:12:45,870
El servidor web dice, "OK".

296
00:12:45,870 --> 00:12:48,780
Basado en el ID de usuario de 
la cookie que este usuario

297
00:12:48,780 --> 00:12:49,720
me ha enviado--

298
00:12:49,720 --> 00:12:52,310
y hay varias medidas de
seguridad y codificación para

299
00:12:52,310 --> 00:12:56,400
asegurar que alguien no está
fingiendo un ID de usuario.

300
00:12:56,400 --> 00:12:59,120
El servidor web entonces irá a--

301
00:12:59,120 --> 00:13:02,730
originalmente usábamos Mongo
para guardar nuestras sesiones.

302
00:13:02,730 --> 00:13:05,380
Usábamos Mongo para almacenar
sesiones porque era simple,

303
00:13:05,380 --> 00:13:06,560
especialmente para Rails.

304
00:13:06,560 --> 00:13:08,840
Había buenos paquetes que
permitían sesiones

305
00:13:08,840 --> 00:13:10,365
almacenadas en Mongo.

306
00:13:10,365 --> 00:13:14,370

307
00:13:14,370 --> 00:13:19,230
Simplemente porque queríamos
reducir el número de consultas

308
00:13:19,230 --> 00:13:20,955
a la base de datos y el número
de veces que estábamos yendo a

309
00:13:20,955 --> 00:13:24,170
la base de datos para una petición,
cambiamos por un almacén de sesiones

310
00:13:24,170 --> 00:13:26,190
Redis.

311
00:13:26,190 --> 00:13:27,850
El cual está dentro de memoria.

312
00:13:27,850 --> 00:13:29,360
Sí, es un porción en memoria.

313
00:13:29,360 --> 00:13:29,940
Y no persiste.

314
00:13:29,940 --> 00:13:31,630
Así que si apagas las
máquinas, aprenderías

315
00:13:31,630 --> 00:13:32,600
el estado de sesión
en ese caso, ¿no?

316
00:13:32,600 --> 00:13:35,550
La diferencia es que Mongo
persistiría la sesión.

317
00:13:35,550 --> 00:13:44,830

318
00:13:44,830 --> 00:13:48,190
Redis es un almacén de
datos compartido y volátil.

319
00:13:48,190 --> 00:13:57,520
Tienen persistencia débil
o no-eventual en disco--

320
00:13:57,520 --> 00:13:59,760
nada al nivel de garantía

321
00:13:59,760 --> 00:14:00,950
que provee MongoDB.

322
00:14:00,950 --> 00:14:01,280
Claro.

323
00:14:01,280 --> 00:14:04,230
Así que usas Redis
para el estado de sesión.

324
00:14:04,230 --> 00:14:06,950
Lo que ocurre es que un usuario
está en el sitio, está en el

325
00:14:06,950 --> 00:14:08,710
medio de un curso.

326
00:14:08,710 --> 00:14:10,590
Obviamente tienes que saber
cuándo están presentando una

327
00:14:10,590 --> 00:14:12,140
respuesta, a dónde están
presentándola y dónde

328
00:14:12,140 --> 00:14:13,160
están en el curso.

329
00:14:13,160 --> 00:14:15,330
Están enviando, básicamente

330
00:14:15,330 --> 00:14:18,090
la información, más la cookie.

331
00:14:18,090 --> 00:14:20,290
¿Y luego esa cookie es usada para
recuperar el estado de sesión

332
00:14:20,290 --> 00:14:21,960
de Redis y procesan la petición?

333
00:14:21,960 --> 00:14:24,390
¿Así funciona en el servidor?

334
00:14:24,390 --> 00:14:26,410
El estado de sesión no se
mantiene también en el cliente,

335
00:14:26,410 --> 00:14:28,320
se mantiene en Redis
en tus servidores, ¿no?

336
00:14:28,320 --> 00:14:29,080
Sí.

337
00:14:29,080 --> 00:14:30,020
OK.

338
00:14:30,020 --> 00:14:33,980
Y el resto de la
información, una vez que

339
00:14:33,980 --> 00:14:37,000
completan exitosamente una
parte de la lección, eso entra

340
00:14:37,000 --> 00:14:39,370
a Mongo, en los documentos.

341
00:14:39,370 --> 00:14:39,630
Claro.

342
00:14:39,630 --> 00:14:44,950
Entonces, como has resaltado,
Redis no tiene el mismo tipo

343
00:14:44,950 --> 00:14:49,430
de garantía de persistencia
que tiene Mongo.

344
00:14:49,430 --> 00:14:54,150
Así que usamos Redis como esta
capa de almacén rápido de sesiones

345
00:14:54,150 --> 00:14:55,725
Te da el contexto del usuario,

346
00:14:55,725 --> 00:14:56,770
como mencionaste.

347
00:14:56,770 --> 00:15:00,380
Y si la página requiere cargar
el documento del usuario, toda

348
00:15:00,380 --> 00:15:03,910
la representación basada en
estado de la aplicación es

349
00:15:03,910 --> 00:15:05,840
almacenada en Mongo.

350
00:15:05,840 --> 00:15:06,510
Te entiendo.

351
00:15:06,510 --> 00:15:13,835
Así que la sesión no almacena
para nosotros, información

352
00:15:13,835 --> 00:15:16,630
importante, o mejor dicho,
información primaria con estado.

353
00:15:16,630 --> 00:15:19,990
Guardará los meta datos sobre
el estado, almacenará

354
00:15:19,990 --> 00:15:23,440
información contextual que
si se perdería, probablemente

355
00:15:23,440 --> 00:15:26,030
el usuario ni se daría cuenta.

356
00:15:26,030 --> 00:15:29,790
Pero nos ayuda para saber
a dónde tenemos que ir para

357
00:15:29,790 --> 00:15:33,000
cargar la representación con estado
y esto está principalmente en Mongo.

358
00:15:33,000 --> 00:15:37,410
Así que la aplicación web o
el servidor web primero irá

359
00:15:37,410 --> 00:15:40,240
con la cookie, irá a Redis para
cargar el contexto de sesión y

360
00:15:40,240 --> 00:15:43,910
luego eso va a dictaminar lo
que el plan de consulta será

361
00:15:43,910 --> 00:15:49,230
para cargar el estado para cual sea
la página o porción de la aplicación

362
00:15:49,230 --> 00:15:52,910
web que tiene que ser
servida al cliente.

363
00:15:52,910 --> 00:15:55,870
Y luego el servidor
web irá a Mongo

364
00:15:55,870 --> 00:15:59,520
dependiendo del estado.

365
00:15:59,520 --> 00:16:02,220
Casi todo nuestro estado
es persistido en Mongo.

366
00:16:02,220 --> 00:16:03,740
OK.

367
00:16:03,740 --> 00:16:07,620
Creo que en seguida sería
bueno que nos expliques

368
00:16:07,620 --> 00:16:12,080
un poco sobre la evolución de
tu escalamiento con un pizarra

369
00:16:12,080 --> 00:16:14,720
y que nos expliques tal vez
un poco sobre tu esquema y

370
00:16:14,720 --> 00:16:19,430
qué ha sido importante indexar

371
00:16:19,430 --> 00:16:21,160
y algo sobre rendimiento.

372
00:16:21,160 --> 00:16:24,282
Así que vamos a
cambiar a una pizarra.

373
00:16:24,282 --> 00:16:24,650
Está bien.

374
00:16:24,650 --> 00:16:25,090
Me parece muy bien.

375
00:16:25,090 --> 00:16:25,360
Muy bien.

376
00:16:25,360 --> 00:16:26,350
Hagamos eso.

377
00:16:26,350 --> 00:16:26,530
Muy bien.

378
00:16:26,530 --> 00:16:30,090
A ver, explícame un poco
en un nivel alto, cómo

379
00:16:30,090 --> 00:16:32,620
es el sistema y dónde encaja MongoDB.

380
00:16:32,620 --> 00:16:32,900
Claro.

381
00:16:32,900 --> 00:16:33,650
Por supuesto.

382
00:16:33,650 --> 00:16:37,660
Hay tres componentes principales
en Codecademy como un sistema

383
00:16:37,660 --> 00:16:38,670
completo.

384
00:16:38,670 --> 00:16:41,630
Tenemos el cliente, la capa
de aplicación y la capa de

385
00:16:41,630 --> 00:16:42,920
datos.

386
00:16:42,920 --> 00:16:43,710
Y voy a describir los tres.

387
00:16:43,710 --> 00:16:45,440
Obviamente, Mongo está
en la capa de datos.

388
00:16:45,440 --> 00:16:45,900
Claro.

389
00:16:45,900 --> 00:16:50,635
Te tenemos a ti, tu
computadora es el cliente.

390
00:16:50,635 --> 00:16:53,140

391
00:16:53,140 --> 00:16:58,670
Y luego tenemos, llamaré a esto
Rails, y esta es la capa de la

392
00:16:58,670 --> 00:17:02,030
aplicación.

393
00:17:02,030 --> 00:17:04,960
Esta es la capa del cliente,
así que esto es tu navegador.

394
00:17:04,960 --> 00:17:07,530

395
00:17:07,530 --> 00:17:11,760
Y luego tienes la capa de datos.

396
00:17:11,760 --> 00:17:15,170
Y lo representaré como API.

397
00:17:15,170 --> 00:17:18,640
Esto es Rack, como mencioné.

398
00:17:18,640 --> 00:17:22,800
Y se comunica directamente con--

399
00:17:22,800 --> 00:17:27,410
Creo que lo dibujaremos como
la representación tradicional.

400
00:17:27,410 --> 00:17:29,690
Esto es Mongo.

401
00:17:29,690 --> 00:17:32,080
Hay tres componentes principales.

402
00:17:32,080 --> 00:17:34,012
Tenemos la capa del cliente, la
capa de la aplicación y la capa

403
00:17:34,012 --> 00:17:36,360
de los datos.

404
00:17:36,360 --> 00:17:41,980
Queremos encapsular la capa
de los datos para asegurarnos

405
00:17:41,980 --> 00:17:45,450
que haya un interfaz bien
definida para la manera en

406
00:17:45,450 --> 00:17:47,010
que accedemos a Mongo.

407
00:17:47,010 --> 00:17:50,170
Porque como dijimos anteriormente,
accesos inapropiados a Mongo

408
00:17:50,170 --> 00:17:52,620
pueden causar muchos
problemas en producción.

409
00:17:52,620 --> 00:17:52,910
Bien.

410
00:17:52,910 --> 00:17:55,310
Entonces abstrayendo estos
tres diferentes componentes

411
00:17:55,310 --> 00:17:59,130
estamos esencialmente asegurando
que podemos enfocarnos en cada

412
00:17:59,130 --> 00:18:01,530
uno individualmente y optimizar
cada uno individualmente, porque

413
00:18:01,530 --> 00:18:03,380
tiene casos de uso
muy diferentes.

414
00:18:03,380 --> 00:18:05,210
Para el cliente obviamente
nos importan cosas como el

415
00:18:05,210 --> 00:18:05,920
tiempo de carga del navegador.

416
00:18:05,920 --> 00:18:06,060
Claro.

417
00:18:06,060 --> 00:18:07,375
Nos importa--

418
00:18:07,375 --> 00:18:10,280
es principalmente una aplicación
JavaScript, por supuesto, nos

419
00:18:10,280 --> 00:18:14,250
importa la complejidad de ello
y también el tamaño de las

420
00:18:14,250 --> 00:18:17,130
peticiones y el tamaño de los
recursos que estás sirviendo--

421
00:18:17,130 --> 00:18:20,520
imágenes, tu CSS,
tu JavaScript, tu HTML.

422
00:18:20,520 --> 00:18:23,150
Para la capa de la aplicación,
tienes mucho acoplamiento.

423
00:18:23,150 --> 00:18:27,170
Tienes muchos componentes
diferentes.

424
00:18:27,170 --> 00:18:30,150
Ahí defines tus peticiones
y cómo se relacionan a las

425
00:18:30,150 --> 00:18:35,050
acciones y los controladores
y luego cómo esos controladores

426
00:18:35,050 --> 00:18:40,050
agregan los datos para
formatearlos dentro de

427
00:18:40,050 --> 00:18:41,450
una buena respuesta.

428
00:18:41,450 --> 00:18:48,270
La API es lo que conecta
la aplicación a Mongo

429
00:18:48,270 --> 00:18:51,380
esencialmente encapsulando
los patrones de acceso.

430
00:18:51,380 --> 00:18:55,880
Así que si la aplicación
quiere, digamos, devolver el

431
00:18:55,880 --> 00:18:58,220
perfil de tu usuario, va a
hacer consultas a varias

432
00:18:58,220 --> 00:18:59,490
colecciones en Mongo.

433
00:18:59,490 --> 00:19:03,660
Así que va a hacer varias
llamadas a la API que hacen

434
00:19:03,660 --> 00:19:06,230
joins a través de varias
colecciones o diferentes

435
00:19:06,230 --> 00:19:07,690
partes de la base de datos.

436
00:19:07,690 --> 00:19:13,460
Y vas a querer optimizar
cómo estás accediendo Mongo

437
00:19:13,460 --> 00:19:15,660
para este diferente
tipo de consultas.

438
00:19:15,660 --> 00:19:21,180
Así que nos zambulliremos un
poco en la capa de datos y cómo

439
00:19:21,180 --> 00:19:25,190
a través de un ciclo de
peticiones vamos del cliente

440
00:19:25,190 --> 00:19:26,490
hasta Mongo y de regreso.

441
00:19:26,490 --> 00:19:27,020
OK.

442
00:19:27,020 --> 00:19:29,070
Me parece bien.

443
00:19:29,070 --> 00:19:32,720
Entonce hay un estudiante sentado
en su computadora y están en el

444
00:19:32,720 --> 00:19:34,240
medio de uno de estos
cursos y tiene que

445
00:19:34,240 --> 00:19:35,010
enviar una respuesta.

446
00:19:35,010 --> 00:19:37,340
Entonces, ¿qué pasa después de eso?
¿Qué pasa después de que envían

447
00:19:37,340 --> 00:19:38,790
la respuesta y tiene
que ser evaluada?

448
00:19:38,790 --> 00:19:39,230
Claro.

449
00:19:39,230 --> 00:19:42,010
Estás sentado frente
a tu computadora.

450
00:19:42,010 --> 00:19:45,880
Estás haciendo un ejercicio
y envías la respuesta.

451
00:19:45,880 --> 00:19:51,550
Así que ni bien presionas "Run",
haz hecho esta petición.

452
00:19:51,550 --> 00:19:55,800
Esta petición va a tener
código y otros meta datos

453
00:19:55,800 --> 00:20:00,420
asociada como tu--

454
00:20:00,420 --> 00:20:02,240
como hablamos antes,
guardamos información

455
00:20:02,240 --> 00:20:04,640
de sesiones en Redis--

456
00:20:04,640 --> 00:20:07,110
así que tendrá su cookie.

457
00:20:07,110 --> 00:20:08,780
Tu cookie tendrá mucha de
estos meta datos, incluyendo

458
00:20:08,780 --> 00:20:12,230
tu ID de usuario.

459
00:20:12,230 --> 00:20:15,290
Al momento de la petición, en
realidad usamos un servicio

460
00:20:15,290 --> 00:20:18,075
externo que evalúa el código
que nosotros creamos y que está

461
00:20:18,075 --> 00:20:19,325
afuera del sistema.

462
00:20:19,325 --> 00:20:21,190

463
00:20:21,190 --> 00:20:22,870
Lo llamamos "codex".

464
00:20:22,870 --> 00:20:25,190
Lo importante es que esto
ocurre afuera de este flujo

465
00:20:25,190 --> 00:20:28,600
y es así por razones
de seguridad.

466
00:20:28,600 --> 00:20:30,880
El código, cuando se envía,
va a ir a codex y va a

467
00:20:30,880 --> 00:20:33,380
regresar con una
respuesta evaluada.

468
00:20:33,380 --> 00:20:36,370
Al final de esa respuesta
evaluada, obtienes el resultado

469
00:20:36,370 --> 00:20:39,480
y luego lo propagamos
y almacenamos.

470
00:20:39,480 --> 00:20:39,800
OK.

471
00:20:39,800 --> 00:20:41,800
Todo esto está "sandboxed".

472
00:20:41,800 --> 00:20:42,075
Sí.

473
00:20:42,075 --> 00:20:42,460
Todo el código está "sandboxed".

474
00:20:42,460 --> 00:20:43,830
Esto ocurre afuera de esto.

475
00:20:43,830 --> 00:20:44,120
OK.

476
00:20:44,120 --> 00:20:46,300
Así que una vez que tienes
tu petición, tienes la respuesta

477
00:20:46,300 --> 00:20:48,710
del evaluador, esto va a Rails.

478
00:20:48,710 --> 00:20:53,760
En Rails, hace una petición
post a un controlador de

479
00:20:53,760 --> 00:20:54,730
presentaciones.

480
00:20:54,730 --> 00:20:56,510
Y esta es una ruta.

481
00:20:56,510 --> 00:20:57,760
La llamaremos presentaciones.

482
00:20:57,760 --> 00:21:01,190

483
00:21:01,190 --> 00:21:03,760
Aquí es donde la aplicación
está recibiendo, en la capa

484
00:21:03,760 --> 00:21:08,130
HTTP, tu petición y
la está procesando.

485
00:21:08,130 --> 00:21:12,470
Así que está tomando tu petición
está jalando de la API los meta

486
00:21:12,470 --> 00:21:14,420
datos apropiados para
saber dónde escribir

487
00:21:14,420 --> 00:21:15,470
el contexto.

488
00:21:15,470 --> 00:21:18,620
Entonces esto va a requerir un--

489
00:21:18,620 --> 00:21:21,080
lo dividiremos en lecturas
y luego lo dividiremos en

490
00:21:21,080 --> 00:21:22,410
escrituras que ocurren.

491
00:21:22,410 --> 00:21:26,500
Entonces esto es lo que
tu usuario va a leer.

492
00:21:26,500 --> 00:21:29,640
Esto será una llamada a la API,
ambos de éstos son llamadas a la

493
00:21:29,640 --> 00:21:31,380
API, como hablamos
sobre esta capa.

494
00:21:31,380 --> 00:21:34,490
Tiene que leer el contexto
del usuario y tiene que

495
00:21:34,490 --> 00:21:36,280
jalar el--lo llamaremos

496
00:21:36,280 --> 00:21:39,680
el contexto de contenido.

497
00:21:39,680 --> 00:21:47,380
Entonces para una presentación,
está asociado con un ejercicio.

498
00:21:47,380 --> 00:21:49,890
Un ejercicio pertenece
a un curso.

499
00:21:49,890 --> 00:21:52,360
Tiene contexto de contenido,
es lo que lo estoy llamando.

500
00:21:52,360 --> 00:21:56,020
Así que va a jalar,
esencialmente, los

501
00:21:56,020 --> 00:21:57,270
datos asociados al ejercicio.

502
00:21:57,270 --> 00:22:00,080

503
00:22:00,080 --> 00:22:04,500
Admás, éstas son las únicas
dos cosas que tenemos que

504
00:22:04,500 --> 00:22:08,230
jalar para hacer una escritura,
para obtener los datos

505
00:22:08,230 --> 00:22:12,120
correspondientes para
escribir tu presentación.

506
00:22:12,120 --> 00:22:14,570
¿Cuáles son la colecciones
principales dentro de

507
00:22:14,570 --> 00:22:16,170
MongoDB que representan esto?

508
00:22:16,170 --> 00:22:18,360
Si vamos a saltar--

509
00:22:18,360 --> 00:22:21,840
la capa de la aplicación no tiene
ningún conocimiento de esto.

510
00:22:21,840 --> 00:22:26,042
Para la capa de la API, no
tiene ningún conocimiento de--

511
00:22:26,042 --> 00:22:29,490

512
00:22:29,490 --> 00:22:35,530
hay una colección de
usuarios, hay una--

513
00:22:35,530 --> 00:22:40,430
lo llamaermos una
colección de secciones.

514
00:22:40,430 --> 00:22:45,870
Una sección tiene
ejercicios embebidos.

515
00:22:45,870 --> 00:22:50,600
Las secciones de un curso para
aprender una habilidad, en este caso.

516
00:22:50,600 --> 00:22:50,860
Claro.

517
00:22:50,860 --> 00:22:53,480
Entonces puedes pensar
de las secciones como

518
00:22:53,480 --> 00:22:54,820
conjuntos de ejercicios.

519
00:22:54,820 --> 00:22:55,220
Sí.

520
00:22:55,220 --> 00:22:55,515
OK.

521
00:22:55,515 --> 00:22:57,110
Pueden haber una variedad de--

522
00:22:57,110 --> 00:22:57,450
capítulos, podrían ser--

523
00:22:57,450 --> 00:23:01,050
de capítulos o diferentes
maneras de mostrar estos

524
00:23:01,050 --> 00:23:03,970
conjuntos a los usuarios,
pero esencialmente decimos

525
00:23:03,970 --> 00:23:05,320
que son conjuntos de ejercicios.

526
00:23:05,320 --> 00:23:06,960
Es un solo documento y contiene

527
00:23:06,960 --> 00:23:08,870
documentos de ejercicios embebidos.

528
00:23:08,870 --> 00:23:11,540
Luego tienes otra colección
llamada presentaciones.

529
00:23:11,540 --> 00:23:13,660
Así que estamos leyendo usuarios
y de secciones y estamos

530
00:23:13,660 --> 00:23:16,680
escribiendo a presentaciones.

531
00:23:16,680 --> 00:23:21,640
Claro, ¿entonces el curso de
aprendizaje está representado

532
00:23:21,640 --> 00:23:22,430
por la colección de secciones?

533
00:23:22,430 --> 00:23:23,100
Sí.

534
00:23:23,100 --> 00:23:28,160
Y no cambia cuando el usuario
va a través del curso.

535
00:23:28,160 --> 00:23:31,380
Esto representa el curso,
y entonces la colección

536
00:23:31,380 --> 00:23:35,140
de presentaciones está
tomando el usuario--

537
00:23:35,140 --> 00:23:37,300
registras el progreso
del usuario aquí.

538
00:23:37,300 --> 00:23:41,130
Y todo el mundo sabe cómo
funciona esto, pero estás

539
00:23:41,130 --> 00:23:42,870
escribiendo código y
está siendo evaluado

540
00:23:42,870 --> 00:23:43,990
y les estás diciendo
si es que obtuvieron el

541
00:23:43,990 --> 00:23:45,210
resultado correcto o no.

542
00:23:45,210 --> 00:23:47,960
Así que esto ocurre en
está esquina aquí.

543
00:23:47,960 --> 00:23:49,570
Esto ocurre completamente
afuera de este sitio.

544
00:23:49,570 --> 00:23:49,840
OK.

545
00:23:49,840 --> 00:23:52,980
Sólo porque no puedes
confiar en código que

546
00:23:52,980 --> 00:23:54,800
ha sido escrito por el usuario.

547
00:23:54,800 --> 00:23:58,120
Sí, no queremos que este
servicio tenga conocimiento

548
00:23:58,120 --> 00:24:01,480
de cualquier otra parte
de este servicio.

549
00:24:01,480 --> 00:24:02,080
Claro.

550
00:24:02,080 --> 00:24:05,260
Entonces cuando todo esto
llega aquí, ya sabrás

551
00:24:05,260 --> 00:24:08,120
si es que el estudiante
obtuvo la respuesta correcta.

552
00:24:08,120 --> 00:24:08,370
Así es.

553
00:24:08,370 --> 00:24:13,810
Tanto el código que
presentaste y el resultado

554
00:24:13,810 --> 00:24:19,210
o repuesta, supongo, de tu
código, además de cualquier

555
00:24:19,210 --> 00:24:24,080
error que obtuviste y cualquier
otro tipo de información que

556
00:24:24,080 --> 00:24:28,210
obtuvimos al ejecutar o
evaluar el codígo en un

557
00:24:28,210 --> 00:24:29,660
ambiente.

558
00:24:29,660 --> 00:24:30,910
¿Puedes hablar un poco sobre--

559
00:24:30,910 --> 00:24:34,040

560
00:24:34,040 --> 00:24:35,830
el tamaño de la colección?

561
00:24:35,830 --> 00:24:37,360
La colección de presentaciones
es la más grande.

562
00:24:37,360 --> 00:24:40,420
La de usuarios es más pequeña
y la de secciones es probablemente

563
00:24:40,420 --> 00:24:43,850
muy pequeña, porque
es sólo los cursos

564
00:24:43,850 --> 00:24:44,600
mismos.

565
00:24:44,600 --> 00:24:45,230
Claro.

566
00:24:45,230 --> 00:24:48,510
Hablaré un poco sobre
qué orden de magnitud

567
00:24:48,510 --> 00:24:49,700
tenemos aquí.

568
00:24:49,700 --> 00:24:52,270
Creo que para termina con lo
de las llamadas a la API acá.

569
00:24:52,270 --> 00:24:52,500
Claro.

570
00:24:52,500 --> 00:24:54,355
Entonces cuando tienes
tu petición, esto va a

571
00:24:54,355 --> 00:24:55,225
la capa de la aplicación.

572
00:24:55,225 --> 00:24:58,555
Esto va a esta ruta
como una petición post.

573
00:24:58,555 --> 00:25:01,740

574
00:25:01,740 --> 00:25:05,600
Luego esto la tiene lecturas
para el usuario en esta colección

575
00:25:05,600 --> 00:25:09,450
a través de la API y luego
lecturas a secciones.

576
00:25:09,450 --> 00:25:13,750
Así que ahora que sabemos
exactamente que colecciones

577
00:25:13,750 --> 00:25:17,030
estamos consultando,
llamaré a esto una sección.

578
00:25:17,030 --> 00:25:19,150
Este es el ejercicio
de la sección en cuestión.

579
00:25:19,150 --> 00:25:21,260
Y luego las escrituras
son a presentaciones.

580
00:25:21,260 --> 00:25:22,060
Te entiendo.

581
00:25:22,060 --> 00:25:24,770
OK.

582
00:25:24,770 --> 00:25:26,560
Y esto luego va a la API.

583
00:25:26,560 --> 00:25:31,130
La API es lo que contiene
el driver que está haciendo

584
00:25:31,130 --> 00:25:35,578
las lecturas y escrituras
directamente desde Mongo, y

585
00:25:35,578 --> 00:25:37,800
que hace, lo llamaremos agregación.

586
00:25:37,800 --> 00:25:39,570
No es el Aggregation Framework.

587
00:25:39,570 --> 00:25:41,290
Estoy usando el término
genéricamente.

588
00:25:41,290 --> 00:25:43,860
Desde cuando hace sus lecturas
y luego al hacer la agregación,

589
00:25:43,860 --> 00:25:44,840
hace sus escrituras.

590
00:25:44,840 --> 00:25:46,180
Y luego enviamos la respuesta.

591
00:25:46,180 --> 00:25:49,102
Y el cliente sabe que ha
habido una escritura exitosa

592
00:25:49,102 --> 00:25:54,780
y no reenviará la petición.

593
00:25:54,780 --> 00:25:56,930
Si, por supuesto, hay
alguna falla, entonces

594
00:25:56,930 --> 00:26:00,390
hay un número exponencial
de intentos para asegurarse

595
00:26:00,390 --> 00:26:02,150
de que la petición pasó.

596
00:26:02,150 --> 00:26:07,450
Muchos de los detalles
interesantes acá están en

597
00:26:07,450 --> 00:26:09,860
como lidiamos con estas
diferentes colecciones y

598
00:26:09,860 --> 00:26:12,860
las diferentes órdenes de
magnitud que tenemos.

599
00:26:12,860 --> 00:26:16,420
Hemos guardado la presentaciones
de los usuarios desde el comienzo.

600
00:26:16,420 --> 00:26:20,040
Y en el año y algunos meses que
el sitio ha estado en producción

601
00:26:20,040 --> 00:26:21,970
hemos recolectado millones de

602
00:26:21,970 --> 00:26:22,650
presentaciones.

603
00:26:22,650 --> 00:26:23,070
Wow.

604
00:26:23,070 --> 00:26:27,150
Y por supuesto, esto resulta
en mucho retos, especialmente

605
00:26:27,150 --> 00:26:30,940
por el volumen, pero también
por el hecho que el código que

606
00:26:30,940 --> 00:26:33,940
la gente está presentando
varía mucho en tamaño.

607
00:26:33,940 --> 00:26:37,990
Entonces un documento de presentación
si optaríamos por incluir el código

608
00:26:37,990 --> 00:26:40,620
que está siendo presentado,
cada documento de presentación

609
00:26:40,620 --> 00:26:45,340
podría tener desde algunas decenas
de bytes hasta cientos de kilobytes

610
00:26:45,340 --> 00:26:46,850
o hasta un megabyte.

611
00:26:46,850 --> 00:26:49,150
No sé en cuánto detalle han
entrado respecto a la compactación

612
00:26:49,150 --> 00:26:51,770
en MongoDB, pero eso puede llevar

613
00:26:51,770 --> 00:26:55,290
a un almacenaje ineficiente
dentro de MongoDB.

614
00:26:55,290 --> 00:26:56,100
Claro.

615
00:26:56,100 --> 00:26:59,960
Así que podemos hablar un
poco más sobre la evolución

616
00:26:59,960 --> 00:27:02,200
de la colección de presentaciones,
la cual nos ha planteado varios

617
00:27:02,200 --> 00:27:04,400
retos a nosotros mientras
hemos escalado--

618
00:27:04,400 --> 00:27:07,380
tanto cuando comenzamos
como donde estamos hoy.

619
00:27:07,380 --> 00:27:07,530
Claro.

620
00:27:07,530 --> 00:27:08,520
Hablemos sobre ello.

621
00:27:08,520 --> 00:27:13,050
Me estabas contando antes
que están en un ambiente

622
00:27:13,050 --> 00:27:14,740
replicado, pero sin "shards",
pero que en el pasado,

623
00:27:14,740 --> 00:27:16,430
han tenido "shards".

624
00:27:16,430 --> 00:27:20,710
De repente puedes llevar
a los estudiantes a través

625
00:27:20,710 --> 00:27:23,880
de la evolución de esa decisión
y como lograron ir de con "shards"

626
00:27:23,880 --> 00:27:28,660
a sin "shards", lo cual es
obviamente más fácil de administrar

627
00:27:28,660 --> 00:27:30,030
debido a su incremento en rendimiento.

628
00:27:30,030 --> 00:27:32,075
Así que si pudieras
hablar sobre eso.

629
00:27:32,075 --> 00:27:32,630
Claro.

630
00:27:32,630 --> 00:27:37,100
Hay tres diferentes épocas
o versiones de la colección

631
00:27:37,100 --> 00:27:38,010
de presentaciones.

632
00:27:38,010 --> 00:27:39,900
Creo que puedo borrar
esto y luego podemos--

633
00:27:39,900 --> 00:27:40,500
Sí, por supuesto.

634
00:27:40,500 --> 00:27:42,130
--entrar en más
detalle sobre eso.

635
00:27:42,130 --> 00:27:46,470
Así que como mencioné, hay
tres diferentes versiones o

636
00:27:46,470 --> 00:27:49,620
generaciones de nuestra
colección de presentaciones.

637
00:27:49,620 --> 00:27:51,885
Primero, era simplemente una
colección pura de presentaciones.

638
00:27:51,885 --> 00:27:56,480

639
00:27:56,480 --> 00:28:00,460
Tenía cosas como ID de ejercicio--

640
00:28:00,460 --> 00:28:03,500
este es el contexto
del contenido.

641
00:28:03,500 --> 00:28:06,400
ID del usuario.

642
00:28:06,400 --> 00:28:11,170
Y éste era una clave única
compuesta de los IDs

643
00:28:11,170 --> 00:28:12,280
de ejercicio y usuario.

644
00:28:12,280 --> 00:28:16,900
Así que podemos entrar en
más detalle respecto a cómo

645
00:28:16,900 --> 00:28:18,650
introducimos índices en
esta segunda generación.

646
00:28:18,650 --> 00:28:20,360
¿Dijiste que era en ID de
ejercicios coma ID de usuario?

647
00:28:20,360 --> 00:28:22,180
¿O ID de usuario coma
ID de ejercicio?

648
00:28:22,180 --> 00:28:23,600
¿Cuál era el índice?

649
00:28:23,600 --> 00:28:24,910
ID de usuario, ID de ejercicio.

650
00:28:24,910 --> 00:28:26,160
ID de usuario, ID de ejercicio.

651
00:28:26,160 --> 00:28:30,390
Y luego teníamos este
array para las respuestas.

652
00:28:30,390 --> 00:28:34,540
Las repuestas son lo que
guardaban el contenido enviado.

653
00:28:34,540 --> 00:28:38,650
Entonces esto sería un array de
documentos de respuesta embebidos

654
00:28:38,650 --> 00:28:41,970
y tenían cosas como, digamos

655
00:28:41,970 --> 00:28:45,600
la entrada actual.

656
00:28:45,600 --> 00:28:51,290
Esto sería el código
que escribió el usuario.

657
00:28:51,290 --> 00:28:52,920
Y luego habría información

658
00:28:52,920 --> 00:28:57,040
adicional, como un "timestamp".

659
00:28:57,040 --> 00:29:01,110
Usamos abreviaciones para los
nombres de propiedades o claves

660
00:29:01,110 --> 00:29:03,240
porque se incluyen en el
tamaño del documento, pero

661
00:29:03,240 --> 00:29:04,490
voy a escribirlas acá
completamente.

662
00:29:04,490 --> 00:29:07,040

663
00:29:07,040 --> 00:29:12,810
Así que usas claves abreviadas
porque reduce el tamaño de tu

664
00:29:12,810 --> 00:29:17,360
huella de datos en Mongo.

665
00:29:17,360 --> 00:29:20,630
Sí, porque estás serializando
tu documento a una representación

666
00:29:20,630 --> 00:29:22,180
binaria.

667
00:29:22,180 --> 00:29:25,960
Los nombres de las propiedades
en tu documento adjunto
están incluidas en el

668
00:29:25,960 --> 00:29:27,610
tamaño del documento.

669
00:29:27,610 --> 00:29:28,540
Claro.

670
00:29:28,540 --> 00:29:31,270
Como resultado, es algo
que fácilmente puedes

671
00:29:31,270 --> 00:29:33,950
optimizar, especialmente si estás
dividiendo tus aplicaciones

672
00:29:33,950 --> 00:29:37,005
en estas diferentes interfaces
entre tu capa de datos y la

673
00:29:37,005 --> 00:29:37,930
capa de tu aplicación.

674
00:29:37,930 --> 00:29:44,340
Es muy fácil de hacer, simplemente
en el código de tu API, haces una

675
00:29:44,340 --> 00:29:47,910
relación simple, donde estás
convirtiendo el texto completo

676
00:29:47,910 --> 00:29:50,930
o la versión completa del
nombre de la propiedad

677
00:29:50,930 --> 00:29:52,910
y la versión abreviada
del nombre de la propiedad.

678
00:29:52,910 --> 00:29:52,985
Claro.

679
00:29:52,985 --> 00:29:54,130
Entonces los desarrolladores
tienen el beneficio de nombres

680
00:29:54,130 --> 00:29:56,900
intuitivos y tienes la
eficiencia que viene con

681
00:29:56,900 --> 00:29:59,795
nombres más cortos dentro
de las colecciones de MongoDB.

682
00:29:59,795 --> 00:30:00,130
Claro.

683
00:30:00,130 --> 00:30:03,800
Y si tienes un gran volumen
de documentos que son relativamente

684
00:30:03,800 --> 00:30:07,450
pequeños, los nombres de tus
propiedades pueden ser hasta

685
00:30:07,450 --> 00:30:11,650
un cuarto o mitad, en algunos
casos, del tamaño de tus

686
00:30:11,650 --> 00:30:13,030
documentos.

687
00:30:13,030 --> 00:30:15,870
Así que el hacer una
abreviación simple puede

688
00:30:15,870 --> 00:30:17,280
reducir el tamaño de
una colección a la mitad.

689
00:30:17,280 --> 00:30:17,870
Sí.

690
00:30:17,870 --> 00:30:21,060
Entonces para ir a la estructura
general acá, así es como

691
00:30:21,060 --> 00:30:22,420
comenzamos inicialmente.

692
00:30:22,420 --> 00:30:25,030
Es un simple ID de ejercicio,
un ID de usuario y luego un

693
00:30:25,030 --> 00:30:25,660
array de respuestas.

694
00:30:25,660 --> 00:30:28,050
Están ordenadas.

695
00:30:28,050 --> 00:30:30,260
Teníamos un límite arbitario
para el tamaño de este array.

696
00:30:30,260 --> 00:30:33,515
Obviamente podría crecer
de manera descontrolada.

697
00:30:33,515 --> 00:30:34,630
Simplemente teníamos
un límite impuesto.

698
00:30:34,630 --> 00:30:38,160
Era muy fácil mantener
el tamaño haciendo "pushes"

699
00:30:38,160 --> 00:30:40,360
y "pops" atómicos.

700
00:30:40,360 --> 00:30:41,830
Y eso era todo.

701
00:30:41,830 --> 00:30:46,150
Así que lo que en verdad era
interesante aquí mientras esta

702
00:30:46,150 --> 00:30:50,370
colección crecía, por supuesto
que creció rápidamente a los

703
00:30:50,370 --> 00:30:53,030
millones. Teníamos que ser
muy cuidados y explícitos

704
00:30:53,030 --> 00:30:54,060
con los índices que
estábamos usando.

705
00:30:54,060 --> 00:30:58,340
Y un problema que teníamos
originalmente era que,

706
00:30:58,340 --> 00:31:02,180
ocasionalmente, si alguien
hacía "Submit" dos veces

707
00:31:02,180 --> 00:31:05,930
en sucesión rápida, no
podíamos hacer una búsqueda

708
00:31:05,930 --> 00:31:07,490
atómica y luego una escritura.

709
00:31:07,490 --> 00:31:10,390
No estábamos haciendo un "upsert".

710
00:31:10,390 --> 00:31:13,980
Y si usábamos un "upsert",
no lo haría 100% del tiempo

711
00:31:13,980 --> 00:31:15,890
porque estábamos usando un ODM.

712
00:31:15,890 --> 00:31:17,700
No podíamos garantizar
singularidad.

713
00:31:17,700 --> 00:31:20,310
Había cosas que podíamos
hacer que nos llevaban lejos,

714
00:31:20,310 --> 00:31:22,430
pero igual no podíamos
garantizar singularidad.

715
00:31:22,430 --> 00:31:25,760
Y queríamos--para mantener 
nuestros datos limpios--

716
00:31:25,760 --> 00:31:29,120
queríamos garantizar singularidad
sobre ID de usuario primero y

717
00:31:29,120 --> 00:31:31,300
luego ID de ejercicio.

718
00:31:31,300 --> 00:31:35,180
Y en Mongo, la manera apropiada
de hacer esto es creando un

719
00:31:35,180 --> 00:31:37,560
índice único compuesto.

720
00:31:37,560 --> 00:31:43,780
Así que algunos índices aquí
que creamos, muy simplemente,

721
00:31:43,780 --> 00:31:47,970
fueron ID de usuario,
UD de ejercicio.

722
00:31:47,970 --> 00:31:48,370
Muy bien.

723
00:31:48,370 --> 00:31:50,540
ID de usuario coma
ID de ejercicio.

724
00:31:50,540 --> 00:31:51,000
Sí.

725
00:31:51,000 --> 00:31:51,210
Perdón.

726
00:31:51,210 --> 00:31:53,930
Usé los "hashes" para
la notación.

727
00:31:53,930 --> 00:31:56,520
O el símbolo numeral.

728
00:31:56,520 --> 00:31:59,760
Y esto era único.

729
00:31:59,760 --> 00:32:01,060
Claro.

730
00:32:01,060 --> 00:32:04,230
Y eso, por supuesto, te
garantiza que no estás

731
00:32:04,230 --> 00:32:06,950
creado documentos duplicados
para estos dos campos.

732
00:32:06,950 --> 00:32:07,880
Sí.

733
00:32:07,880 --> 00:32:10,100
Ésa también es la información que
conoces cuando el usuario presenta

734
00:32:10,100 --> 00:32:11,690
la respuesta de un ejercicio.

735
00:32:11,690 --> 00:32:11,840
Claro.

736
00:32:11,840 --> 00:32:14,540
Y esto es cómo relacionamos
un usuario para un ejercicio

737
00:32:14,540 --> 00:32:15,480
al contenido presentado.

738
00:32:15,480 --> 00:32:19,780
Queremos asegurarnos que hay
un solo documento en la base

739
00:32:19,780 --> 00:32:22,210
de datos asociado a estos dos

740
00:32:22,210 --> 00:32:27,730
valores y que estamos
garantizando que estamos

741
00:32:27,730 --> 00:32:29,200
guardando todas tus
presentaciones en el

742
00:32:29,200 --> 00:32:30,120
orden correcto.

743
00:32:30,120 --> 00:32:30,340
Muy bien.

744
00:32:30,340 --> 00:32:31,150
Y estos nunca cambian.

745
00:32:31,150 --> 00:32:35,180
Así que una vez que adjuntas
algo a este array de respuestas,

746
00:32:35,180 --> 00:32:35,920
nunca va a ser editado.

747
00:32:35,920 --> 00:32:37,070
¿Es cierto?

748
00:32:37,070 --> 00:32:37,780
Sí.

749
00:32:37,780 --> 00:32:39,890
Se escribe una vez, y se
lee muchas en ese sentido.

750
00:32:39,890 --> 00:32:40,520
Claro.

751
00:32:40,520 --> 00:32:41,230
OK.

752
00:32:41,230 --> 00:32:50,000
Entonces cuando escribes
este documento, ¿básicamente 

753
00:32:50,000 --> 00:32:52,550
puedes simplemente hacer "push" 
al final de este array?

754
00:32:52,550 --> 00:32:52,860
Sí.

755
00:32:52,860 --> 00:32:54,990
Usamos una operación
atómica "push" sobre él.

756
00:32:54,990 --> 00:32:56,610
Usan un "push" atómico.

757
00:32:56,610 --> 00:32:58,126
Un "encuentra-modifica", esencialmente.

758
00:32:58,126 --> 00:32:58,840
Sí.

759
00:32:58,840 --> 00:32:59,595
OK.

760
00:32:59,595 --> 00:33:01,450
Para insertar algo
en este array,

761
00:33:01,450 --> 00:33:06,055
¿hacen algún "padding" de
éstos para asegurar que

762
00:33:06,055 --> 00:33:09,370
mientras crecen, no tiene
que ser movidas en la colección

763
00:33:09,370 --> 00:33:12,630
o dejan que Mongo
se encargue de eso?

764
00:33:12,630 --> 00:33:17,350
Originalmente, dejábamos que
Mongo se encargue de eso, porque

765
00:33:17,350 --> 00:33:19,290
esta era nuestra implementación
cuando teníamos exclusivamente

766
00:33:19,290 --> 00:33:21,050
contenido JavaScript.

767
00:33:21,050 --> 00:33:26,530
No teníamos contenido que
requerían múltiples pestañas

768
00:33:26,530 --> 00:33:27,970
o múltiples tipos de archivos.

769
00:33:27,970 --> 00:33:31,310
No teníamos contenido que
requería escribir una

770
00:33:31,310 --> 00:33:33,660
aplicación entera, simplemente
era una llamada a una función

771
00:33:33,660 --> 00:33:35,120
o un simple método.

772
00:33:35,120 --> 00:33:39,300
Entonces la variación en
el tamaño de estos archivos

773
00:33:39,300 --> 00:33:40,280
era de una o dos
órdenes de magnitud.

774
00:33:40,280 --> 00:33:44,380
Entonces Mongo hacía una labor
decente, determinando la cantidad

775
00:33:44,380 --> 00:33:46,030
de "padding" que se requería.

776
00:33:46,030 --> 00:33:49,870
Mientras comenzamos a usar tipos
complejos de contenido y aceptar

777
00:33:49,870 --> 00:33:51,660
presentaciones más complejas,

778
00:33:51,660 --> 00:33:53,150
eso, por supuesto, cambió.

779
00:33:53,150 --> 00:33:55,740
Creo que podemos hablar de
la segunda generación y cómo

780
00:33:55,740 --> 00:34:00,750
tuvimos que cambiar este esquema
para este nuevo caso de uso.

781
00:34:00,750 --> 00:34:00,980
OK.

782
00:34:00,980 --> 00:34:07,610
Esto es, digamos, la primera
generación y es más o menos,

783
00:34:07,610 --> 00:34:13,360
digamos, una orden de magnitud
de un millón de presentaciones.

784
00:34:13,360 --> 00:34:20,205
Entonces para esta segunda
generación, esto es cuando

785
00:34:20,205 --> 00:34:23,460
vamos a, digamos, la siguiente
orden de magnitud, más o menos

786
00:34:23,460 --> 00:34:28,290
10 millones con una alta
variedad en tamaño de documento.

787
00:34:28,290 --> 00:34:30,520
Así que mantuvimos varias cosas.

788
00:34:30,520 --> 00:34:32,690
Algunas de las cosas
que cambiamos fueron--

789
00:34:32,690 --> 00:34:36,159

790
00:34:36,159 --> 00:34:39,380
mantuvimos gran parte del
esquema y lo que en verdad

791
00:34:39,380 --> 00:34:41,590
cambiamos fue nuestra
implementación de Mongo.

792
00:34:41,590 --> 00:34:42,620
Hicimos algunas cosas.

793
00:34:42,620 --> 00:34:44,980
Mejoramos nuestras máquinas.

794
00:34:44,980 --> 00:34:47,870
Así que Mongo, para nosotros
está "hosted" en EC2.

795
00:34:47,870 --> 00:34:51,469
Antes, en la primera generación
usábamos un "cloud-hosting" 

796
00:34:51,469 --> 00:34:52,980
ofrecido por terceros.

797
00:34:52,980 --> 00:34:54,550
Nos movimos a EC2.

798
00:34:54,550 --> 00:34:58,525
Estamos corriendo aquí sobre
grandes instancias de memoria

799
00:34:58,525 --> 00:35:00,280
"quad extra".

800
00:35:00,280 --> 00:35:03,720
Así que incrementamos significativamente
la cantidad de memoria que nos era

801
00:35:03,720 --> 00:35:04,965
disponible.

802
00:35:04,965 --> 00:35:07,580
Mientras esta colección crecía
cada vez más, necesitaba

803
00:35:07,580 --> 00:35:12,600
estar en memoria y como
resultado, fue fácil para

804
00:35:12,600 --> 00:35:15,170
nosotros escalar verticalmente
simplemente proveyendo hardware

805
00:35:15,170 --> 00:35:16,380
más significativo.

806
00:35:16,380 --> 00:35:16,850
Claro.

807
00:35:16,850 --> 00:35:19,555
Escalar hacia arriba en
lugar de hacia abajo.

808
00:35:19,555 --> 00:35:19,850
Sí.

809
00:35:19,850 --> 00:35:20,170
En lugar de escalar hacia abajo.

810
00:35:20,170 --> 00:35:23,970
¿Compraron hardware
más grande y SSD?

811
00:35:23,970 --> 00:35:24,960
¿O sólo regular?

812
00:35:24,960 --> 00:35:26,710
Me parece que SSD no estaba
disponible cuando tú--

813
00:35:26,710 --> 00:35:29,960
No estaba disponible y creo
que hay casos de uso particulares

814
00:35:29,960 --> 00:35:32,330
donde te beneficias
significativamente

815
00:35:32,330 --> 00:35:35,840
usando SSDs, pero para nosotros
nos era suficiente usar EBS.

816
00:35:35,840 --> 00:35:37,260
Claro.

817
00:35:37,260 --> 00:35:37,910
Escalamos hacia arriba.

818
00:35:37,910 --> 00:35:43,010
Nos fuimos a instancias
de memoria grandes 4x.

819
00:35:43,010 --> 00:35:45,780

820
00:35:45,780 --> 00:35:52,230
Sí usamos IOPS abastecido.

821
00:35:52,230 --> 00:35:56,050
IOPS abastecido, lo cual es una
característica de "Elastic Block

822
00:35:56,050 --> 00:35:57,840
Store" en "Amazon Web Services".

823
00:35:57,840 --> 00:35:58,420
Sí.

824
00:35:58,420 --> 00:36:03,370
Eso te garantiza cierto ancho
de banda entre el almacén de

825
00:36:03,370 --> 00:36:05,300
red EBS y tu instancia.

826
00:36:05,300 --> 00:36:09,060
Si estás en un EBS tradicional,
no hay garantía de ancho de banda

827
00:36:09,060 --> 00:36:12,700
y puede fluctuar sin control,
lo cual, por supuesto, para

828
00:36:12,700 --> 00:36:16,290
un almacén en memoria que debe
estar en memoria, pero no siempre

829
00:36:16,290 --> 00:36:17,510
lo está, necesitas un
backup garantiza ahí.

830
00:36:17,510 --> 00:36:18,760
Claro.

831
00:36:18,760 --> 00:36:20,520

832
00:36:20,520 --> 00:36:25,840
También pusimos un
conjunto de réplicas.

833
00:36:25,840 --> 00:36:26,340
Claro.

834
00:36:26,340 --> 00:36:27,170
Lo cual es la mejor práctica.

835
00:36:27,170 --> 00:36:28,260
Definitivamente necesitas
usar un conjunto de réplicas.

836
00:36:28,260 --> 00:36:28,570
Claro.

837
00:36:28,570 --> 00:36:32,740
No escalas horizontalmente
como lo haces con "shards",

838
00:36:32,740 --> 00:36:36,670
pero si creó varias
máquinas de las cuales

839
00:36:36,670 --> 00:36:38,390
podíamos hacer lecturas.

840
00:36:38,390 --> 00:36:42,965
Claro, decidiste leer de
tus secundarios, lo que

841
00:36:42,965 --> 00:36:46,430
significó que también estás
lidiando con consistencia

842
00:36:46,430 --> 00:36:47,600
eventual versus consistencia fuerte.

843
00:36:47,600 --> 00:36:48,600
Claro.

844
00:36:48,600 --> 00:36:53,970
Teníamos un solo primario,
por supuesto y dos

845
00:36:53,970 --> 00:36:55,220
secundarios.

846
00:36:55,220 --> 00:36:57,500

847
00:36:57,500 --> 00:37:01,730
Y hacíamos escrituras
al primario y lecturas

848
00:37:01,730 --> 00:37:03,740
de los secundarios.

849
00:37:03,740 --> 00:37:07,470
Y la razón por la cuál hicimos
eso fue para garantizar que

850
00:37:07,470 --> 00:37:13,790
pudiéramos escalar horizontalmente
las lecturas y una máquina era

851
00:37:13,790 --> 00:37:15,775
suficiente para manejar la carga
de escrituras que teníamos en

852
00:37:15,775 --> 00:37:16,730
ese entonces.

853
00:37:16,730 --> 00:37:21,030
Es principalmente una aplicación
con muchas lecturas.

854
00:37:21,030 --> 00:37:25,560
Y esto nos ayudaba a asegurar
que en el caso de una falla

855
00:37:25,560 --> 00:37:29,420
tanto uno de los secundarios
sea promovido, como que

856
00:37:29,420 --> 00:37:31,490
la carga sea balanceada si es

857
00:37:31,490 --> 00:37:32,740
que un secundario fallaba.

858
00:37:32,740 --> 00:37:37,070
Pero también, como dije, nos
dejaba escalar horizontalmente

859
00:37:37,070 --> 00:37:40,580
nuestras lecturas de manera que
si la lectura incrementaba

860
00:37:40,580 --> 00:37:43,130
significativamente, podíamos
agregar más secundarios.

861
00:37:43,130 --> 00:37:43,560
Claro.

862
00:37:43,560 --> 00:37:47,790
Y hay algo de debate dentro de
10gen sobre si ésta es o no

863
00:37:47,790 --> 00:37:49,870
la mejor manera de escalar
lecturas o si estarías mejor

864
00:37:49,870 --> 00:37:51,480
agregando "shards".

865
00:37:51,480 --> 00:37:52,100
Sí.

866
00:37:52,100 --> 00:37:53,960
Dejando de lado los problemas
de consistencia, que es el hecho

867
00:37:53,960 --> 00:37:56,970
que dejas que tu aplicación
tolere leer datos que pueden

868
00:37:56,970 --> 00:37:59,630
ser diferentes de
lo que escribiste.

869
00:37:59,630 --> 00:38:02,290
En términos de desacelerar
los secundarios y desacelerar

870
00:38:02,290 --> 00:38:06,080
la replicación, tienes que asegurarte,
por supuesto, que desde el punto de

871
00:38:06,080 --> 00:38:08,370
vista de planeamiento de
capacidad, que éstos sea lo  

872
00:38:08,370 --> 00:38:13,190
suficientemente grandes. Frecuentemente
la gente compra máquinas más baratas para

873
00:38:13,190 --> 00:38:17,070
sus secundarios y tienen problemas
manteniendo la replicación si es

874
00:38:17,070 --> 00:38:20,120
el la cargan a éste
con lecturas. 

875
00:38:20,120 --> 00:38:23,750
No todo el mundo recomienda eso,
pero definitivamente muchos

876
00:38:23,750 --> 00:38:24,740
usuarios lo hacen.

877
00:38:24,740 --> 00:38:29,200
Escalan lecturas usando
replicación versus sharding.

878
00:38:29,200 --> 00:38:32,230
Y hablamos un poco sobre eso
en la parte sobre ingeniería

879
00:38:32,230 --> 00:38:33,050
de aplicaciones.

880
00:38:33,050 --> 00:38:33,380
Sí.

881
00:38:33,380 --> 00:38:33,710
Definitivamente.

882
00:38:33,710 --> 00:38:37,080
Había algunas lecturas que
tenían que ir al primario.

883
00:38:37,080 --> 00:38:41,350
Si necesitábamos garantizar
consistencia, en lugar de

884
00:38:41,350 --> 00:38:44,530
usar una configuración de
sesión secundaria, usábamos

885
00:38:44,530 --> 00:38:48,420
una configuración de sesión
primaria, donde escribíamos

886
00:38:48,420 --> 00:38:49,130
y leíamos del primario.

887
00:38:49,130 --> 00:38:52,100
Y eso era suficiente,
pero por supuesto, como

888
00:38:52,100 --> 00:38:54,340
decías, requiere que los
desarrolladores entiendan

889
00:38:54,340 --> 00:38:57,890
la implementación de tu capa
de datos y entiendan cuando

890
00:38:57,890 --> 00:38:59,300
tienes una garantía de consistencia

891
00:38:59,300 --> 00:39:00,510
y cuando no.

892
00:39:00,510 --> 00:39:01,220
Y, clar.,

893
00:39:01,220 --> 00:39:04,790
Esto no siempre es fácil o ideal.

894
00:39:04,790 --> 00:39:07,390
Después de esto, estábamos muy
felices con la implementación--

895
00:39:07,390 --> 00:39:07,880
Claro.

896
00:39:07,880 --> 00:39:10,140
Ésta es la segunda generación.

897
00:39:10,140 --> 00:39:11,400
Generación dos.

898
00:39:11,400 --> 00:39:15,720
Nosotros, mientras crecíamos,
tuvimos que buscar una manera

899
00:39:15,720 --> 00:39:17,740
alternativa de escalar
horizontalmente.

900
00:39:17,740 --> 00:39:19,900
Creo que podríamos hablar
un poco sobre eso.

901
00:39:19,900 --> 00:39:20,135
Claro.

902
00:39:20,135 --> 00:39:20,370
Perfecto.

903
00:39:20,370 --> 00:39:24,380
Así que vamos a la
tercera generación.

904
00:39:24,380 --> 00:39:27,000
Hicimos algunas cosas acá.

905
00:39:27,000 --> 00:39:29,460
Estamos en el order de cientos
de millones de presentaciones.

906
00:39:29,460 --> 00:39:34,040
Así que estamos necesitando
unos requerimientos de almacenaje

907
00:39:34,040 --> 00:39:35,110
serio, porque no son simples

908
00:39:35,110 --> 00:39:36,650
entradas en un registro.

909
00:39:36,650 --> 00:39:40,770
Son documentos muy grandes que
potencialmente tiene un array

910
00:39:40,770 --> 00:39:44,710
de respuestas que puede
contener un megabyte o más.

911
00:39:44,710 --> 00:39:45,490
Claro.

912
00:39:45,490 --> 00:39:48,860
Y como sabemos, hay un límite
fijo para un documento y nuestro

913
00:39:48,860 --> 00:39:51,910
contenido se estaba volviendo
más complicado, más elaborado,

914
00:39:51,910 --> 00:39:55,410
complejo, y los tipos de
presentaciones o respuestas

915
00:39:55,410 --> 00:39:58,150
para el contenido, estaba también
volviéndose más complejo.

916
00:39:58,150 --> 00:40:00,760
Comenzamos a introducir
cursos web. Comenzamos

917
00:40:00,760 --> 00:40:01,910
a introducir cursos donde
las personas construían

918
00:40:01,910 --> 00:40:03,140
programas de verdad.

919
00:40:03,140 --> 00:40:06,690
Entonces vimos que las presentaciones
estaban asemejando cada vea más

920
00:40:06,690 --> 00:40:09,400
archivos de proyectos.

921
00:40:09,400 --> 00:40:10,170
Claro.

922
00:40:10,170 --> 00:40:12,840
Entonces comenzamos a usar Mongo
como un almacén de archivos,

923
00:40:12,840 --> 00:40:14,200
lo cual no es su propósito.

924
00:40:14,200 --> 00:40:14,900
Sí.

925
00:40:14,900 --> 00:40:17,510
Hay algo de GridFS, claro.

926
00:40:17,510 --> 00:40:19,020
Personalmente, nunca
me ha gustado guardar

927
00:40:19,020 --> 00:40:20,360
cosas grandes en
bases de datos.

928
00:40:20,360 --> 00:40:21,916
Me parece que están mejor
en sistemas de archivos.

929
00:40:21,916 --> 00:40:22,690
Pero.

930
00:40:22,690 --> 00:40:23,950
Entonces, claro.

931
00:40:23,950 --> 00:40:27,010
Lo primero que hicimos aquí
para la tercera generación,

932
00:40:27,010 --> 00:40:32,240
fue tomar nuestro array de preguntas
y tomar un campo de entrada de cada

933
00:40:32,240 --> 00:40:35,570
uno de estos documentos
y almacenarlos en S3.

934
00:40:35,570 --> 00:40:42,495
Así que usamos almacenaje S3
para las respuestas.

935
00:40:42,495 --> 00:40:45,260

936
00:40:45,260 --> 00:40:48,840
Y tratamos S3 como un
almacén de clave/valor.

937
00:40:48,840 --> 00:40:52,470
Usamos un hash de los contenidos
para que estén esencialmente

938
00:40:52,470 --> 00:40:53,720
garantizados--

939
00:40:53,720 --> 00:40:55,575

940
00:40:55,575 --> 00:40:56,060
Claro.

941
00:40:56,060 --> 00:40:58,600
Tan libre como el servicio
"Amazon Simple Storage", del

942
00:40:58,600 --> 00:41:01,340
cual no estoy seguro de que
hemos hablado mucho, pero

943
00:41:01,340 --> 00:41:03,910
te deja guardar archivos y
garantiza, más que nada,

944
00:41:03,910 --> 00:41:08,080
que los puedas recuperar y
luego te cobra por byte en

945
00:41:08,080 --> 00:41:10,430
términos de cuánto almacenas
por mes y también de acuerdo

946
00:41:10,430 --> 00:41:12,080
a cuánto ancho de
banda usas de Amazon.

947
00:41:12,080 --> 00:41:13,910
Y es muy muy fiable.

948
00:41:13,910 --> 00:41:16,140
Así que si pones algo
en S3, sabes que vas

949
00:41:16,140 --> 00:41:17,220
a poder recuperarlo.

950
00:41:17,220 --> 00:41:17,610
Claro.

951
00:41:17,610 --> 00:41:20,830
Y el único problem entre
S3 y Mongo es, por supuesto,

952
00:41:20,830 --> 00:41:22,490
la latencia de la recuperación.

953
00:41:22,490 --> 00:41:23,040
Sí.

954
00:41:23,040 --> 00:41:25,970
Porque vas a través de
la red y estás usando

955
00:41:25,970 --> 00:41:29,640
otro servicio tienes que tomar
en cuenta esa recuperación.

956
00:41:29,640 --> 00:41:33,120
Nosotros cargamos los documentos
S3 directamente del navegador.

957
00:41:33,120 --> 00:41:39,540
Así que ya no incluimos el historial
de tus entradas de presentación en la

958
00:41:39,540 --> 00:41:40,570
respuesta.

959
00:41:40,570 --> 00:41:42,750
Como hablamos, en la
aplicación principal,

960
00:41:42,750 --> 00:41:44,850
cuando vas a través de la capa
de la aplicación y de la API,

961
00:41:44,850 --> 00:41:47,420
sólo retornamos los meta
datos asociados o guardamos

962
00:41:47,420 --> 00:41:51,160
los meta datos en la
colección de presentaciones.

963
00:41:51,160 --> 00:41:54,190
La entrada en sí está en S3

964
00:41:54,190 --> 00:41:56,050
y esa recuperación
ocurre en el cliente.

965
00:41:56,050 --> 00:42:02,250
Así que nos permite tener un
ciclo de respuesta muy rápido.

966
00:42:02,250 --> 00:42:05,610
Así que usamos un almacén
de respuestas en S3.

967
00:42:05,610 --> 00:42:09,990
Y como resultado, nuestra
colección de presentaciones,

968
00:42:09,990 --> 00:42:20,060
se volvió significativamente más
pequeña y también, cada uno de los

969
00:42:20,060 --> 00:42:21,880
documentos en la colección
de presentaciones de volvió

970
00:42:21,880 --> 00:42:24,760
más consistente respecto a su
tamaño, lo que incrementó

971
00:42:24,760 --> 00:42:26,640
significativamente nuestro
factor de compactación.

972
00:42:26,640 --> 00:42:30,200
Entonces, como resultado,
obtuvimos un incremento o

973
00:42:30,200 --> 00:42:34,210
una mejora aún más grande
con la reducción del tamaño

974
00:42:34,210 --> 00:42:35,925
de la colección, la cual estaba
creciendo muy rápidamente.

975
00:42:35,925 --> 00:42:39,766

976
00:42:39,766 --> 00:42:43,670
Así que en la segunda generación,
¿eventualmente usaron una

977
00:42:43,670 --> 00:42:45,460
configuración con "shards"?

978
00:42:45,460 --> 00:42:47,350
Ésta es la tercera
generación, ¿no?

979
00:42:47,350 --> 00:42:47,610
Sí.

980
00:42:47,610 --> 00:42:49,020
Ésta es la tercera generación.

981
00:42:49,020 --> 00:42:51,850
En la generación dos, los
documentos están creciendo

982
00:42:51,850 --> 00:42:55,250
muy rápido porque estás guardando
todas las respuestas en este array

983
00:42:55,250 --> 00:42:57,940
de respuestas y los ejercicios

984
00:42:57,940 --> 00:42:59,220
están volviéndose
más complejos.

985
00:42:59,220 --> 00:43:02,070
Y toda la información guardada
para cada una de las respuestas

986
00:43:02,070 --> 00:43:03,370
está creciendo.

987
00:43:03,370 --> 00:43:09,260
Y después de que se movieron
a un ambiente replicado, donde

988
00:43:09,260 --> 00:43:12,080
haces tus escrituras a tu
primario y tus lecturas de

989
00:43:12,080 --> 00:43:12,990
tus secundarios--

990
00:43:12,990 --> 00:43:16,230
me dijiste antes, cuando hablamos
anteriormente, que eventualmente

991
00:43:16,230 --> 00:43:18,040
llegaron al punto donde
hasta eso no era suficiente

992
00:43:18,040 --> 00:43:20,120
y decidieron usar
"shards" en el sistema.

993
00:43:20,120 --> 00:43:23,410
¿Puedes hablar un poco sobre
el "sharding" que hicieron y

994
00:43:23,410 --> 00:43:26,820
la clave de "shard" que escogieron
y cómo pensaron sobre ello?
the shard key you chose and
your thinking behind that?

995
00:43:26,820 --> 00:43:27,280
Por supuesto.

996
00:43:27,280 --> 00:43:32,280
Teníamos una colección
de presentaciones que

997
00:43:32,280 --> 00:43:33,630
estaba creciendo rápidamente.

998
00:43:33,630 --> 00:43:36,790
Y por supuesto, cuando
tienes una colección que

999
00:43:36,790 --> 00:43:39,180
está creciendo en volumen y
tamaño y comienzas a sobrecargar

1000
00:43:39,180 --> 00:43:44,180
tus máquinas, una de las soluciones
más comunes para este problema,

1001
00:43:44,180 --> 00:43:45,400
pienso yo, es hacer "sharding".

1002
00:43:45,400 --> 00:43:48,030
Es decir, que vas a dividir
tu colección a través de

1003
00:43:48,030 --> 00:43:49,320
múltiples máquinas.

1004
00:43:49,320 --> 00:43:51,990
Y tienes que dividir esa colección
usando una clave de "shard".

1005
00:43:51,990 --> 00:43:54,240
Y no sé en cuánto detalle han
entrado respecto a cómo escoger

1006
00:43:54,240 --> 00:43:56,260
tu clave de "shard".

1007
00:43:56,260 --> 00:43:57,080
Sí lo cubrimos.

1008
00:43:57,080 --> 00:43:59,550
Y hablamos sobre esto la semana
pasada desde el punto de vista

1009
00:43:59,550 --> 00:44:00,380
de un desarrollador.

1010
00:44:00,380 --> 00:44:02,650
No hemos cubierto extensivamente
cómo hacer una configuración de

1011
00:44:02,650 --> 00:44:05,500
sharding, lo cual es más un
tema para DBAs, pero sí hablamos

1012
00:44:05,500 --> 00:44:08,850
sobre la selección y los
criterio de las claves de "shard".

1013
00:44:08,850 --> 00:44:11,310
¿Qué escogieron ustedes
y cuál fue su razonamiento

1014
00:44:11,310 --> 00:44:12,110
para dicha decisión?

1015
00:44:12,110 --> 00:44:14,470
Escogimos--

1016
00:44:14,470 --> 00:44:16,080
y creo que fue
algo ingenuo.

1017
00:44:16,080 --> 00:44:18,750
Fue un experimento de "sharding".

1018
00:44:18,750 --> 00:44:22,280
Queríamos ver si era una
solución válida para el problema.

1019
00:44:22,280 --> 00:44:25,420
Y cuando escoges una clave de "shard"
quieres que sea algo que no sea

1020
00:44:25,420 --> 00:44:29,300
monótonamente creciente, que
tenga distribución aleatoria

1021
00:44:29,300 --> 00:44:36,340
de acuerdo a cualquiera que
sea su rango y también quieres,

1022
00:44:36,340 --> 00:44:39,520
idealmente, localizar
las consultas.

1023
00:44:39,520 --> 00:44:43,550
Si vas a hacer consultas a
múltiples documentos, vas a

1024
00:44:43,550 --> 00:44:46,080
querer, idealmente, que vengan
de la misma máquina o por lo

1025
00:44:46,080 --> 00:44:47,970
menos que estén
frescos en memoria.

1026
00:44:47,970 --> 00:44:51,740
Para nosotros, eso era en verdad
a través del ID del usuario porque

1027
00:44:51,740 --> 00:44:54,140
nunca, para un sólo ejercicio,
cargaríamos presentaciones de

1028
00:44:54,140 --> 00:44:56,630
múltiples usuarios.

1029
00:44:56,630 --> 00:44:58,510
Siempre sería para un solo
usuario y podría potencialmente

1030
00:44:58,510 --> 00:45:01,500
ser a través de
múltiples ejercicios.

1031
00:45:01,500 --> 00:45:04,620
Así que para nosotros, en
verdad eran sólo dos máquinas.

1032
00:45:04,620 --> 00:45:10,100
Notamos que había distribución
pareja de acceso.

1033
00:45:10,100 --> 00:45:13,770
También un usuario que actualmente
está muy activo, va a estar activo

1034
00:45:13,770 --> 00:45:18,510
por los siguientes momentos,
así que se sienta en memoria

1035
00:45:18,510 --> 00:45:19,530
y funcionaba muy bien.

1036
00:45:19,530 --> 00:45:23,990
No estábamos tan felices con
lo rápido que la colección

1037
00:45:23,990 --> 00:45:27,340
de presentaciones estaba
creciendo, respecto sólo al

1038
00:45:27,340 --> 00:45:31,660
tamaño y no necesariamente a
la cardinalidad del conjunto.

1039
00:45:31,660 --> 00:45:35,630
Entonces, para nosotros, pensamos
que el "sharding" nos daba el

1040
00:45:35,630 --> 00:45:38,060
beneficio de distribuir esta
colección a través de múltiples

1041
00:45:38,060 --> 00:45:41,480
máquinas y los recursos de
cada una, pero pensamos que

1042
00:45:41,480 --> 00:45:43,510
tal vez habría una mejor
solución al tipo de problema

1043
00:45:43,510 --> 00:45:44,860
que estábamos teniendo.

1044
00:45:44,860 --> 00:45:46,860
Ése problema era, esencialmente
que estábamos tratando a MongoDB

1045
00:45:46,860 --> 00:45:50,530
como un almacén de archivos
para las repuestas presentadas.

1046
00:45:50,530 --> 00:45:53,350
¿Así que estás diciendo que
experimentaron, plantearon

1047
00:45:53,350 --> 00:45:55,580
configuraciones experimentales
que tenían "shards", pero nunca

1048
00:45:55,580 --> 00:45:57,640
las usaron en producción con
"sharding" para los usuarios?

1049
00:45:57,640 --> 00:45:59,660
¿O la usaron en producción?

1050
00:45:59,660 --> 00:46:00,590
¿Sí la usamos en producción?

1051
00:46:00,590 --> 00:46:02,465
Esto fue antes de que llegamos--

1052
00:46:02,465 --> 00:46:04,550
creo que hay un tope arbitrario

1053
00:46:04,550 --> 00:46:07,030
de cada shard de como 120 gigabytes.

1054
00:46:07,030 --> 00:46:07,980
No estoy seguro.

1055
00:46:07,980 --> 00:46:10,570
Hay un límite para las
colecciones antes de que

1056
00:46:10,570 --> 00:46:13,800
puedas hacerle "shard" ingenuamente.

1057
00:46:13,800 --> 00:46:15,960
Entonces, antes de que llegamos
a ese tope, queríamos experimentar

1058
00:46:15,960 --> 00:46:17,720
y ver si era la solución con la
que nos queríamos comprometer.

1059
00:46:17,720 --> 00:46:20,010
Es algo que queríamos ver.

1060
00:46:20,010 --> 00:46:23,800
Una vez que comenzamos a
experimentar nos dimos

1061
00:46:23,800 --> 00:46:27,170
cuenta de que había una mejor
solución para nosotros en particular.

1062
00:46:27,170 --> 00:46:27,960
OK.

1063
00:46:27,960 --> 00:46:32,610
¿Así que cuando fueron a
un ambiente con "shards"

1064
00:46:32,610 --> 00:46:33,920
tenían "shards" con
conjuntos de réplicas?

1065
00:46:33,920 --> 00:46:35,130
¿Eso fue lo que hicieron?

1066
00:46:35,130 --> 00:46:35,410
Sí.

1067
00:46:35,410 --> 00:46:37,995
Hicimos "shards" con
conjuntos de réplicas.

1068
00:46:37,995 --> 00:46:42,280
Eran sólo dos "shards".

1069
00:46:42,280 --> 00:46:45,650
Tenían su mongos, ¿no?

1070
00:46:45,650 --> 00:46:47,340
Lo voy a dibujar acá.

1071
00:46:47,340 --> 00:46:53,990

1072
00:46:53,990 --> 00:47:00,340
Tienes tu mongos y ahora tenemos
dos configuraciones de "shard".

1073
00:47:00,340 --> 00:47:03,460
Cada una tiene un primario.

1074
00:47:03,460 --> 00:47:05,525
Y luego estos estaban respaldados
por sólo dos secundarios.

1075
00:47:05,525 --> 00:47:10,170

1076
00:47:10,170 --> 00:47:14,190
Y eso era, creo yo, muy estándar.

1077
00:47:14,190 --> 00:47:16,580
Simplemente estábamos tratando
de obtener una configuración que

1078
00:47:16,580 --> 00:47:18,400
escale horizontalmente de
la manera que queríamos.

1079
00:47:18,400 --> 00:47:21,090
Pero obviamente estás
duplicando tu número

1080
00:47:21,090 --> 00:47:22,810
de máquinas.

1081
00:47:22,810 --> 00:47:27,650
No pensamos que era necesariamente
la manera más eficaz de solucionar

1082
00:47:27,650 --> 00:47:30,610
el problema y estábamos
tratando de identificar

1083
00:47:30,610 --> 00:47:32,280
cuál era nuestro
verdadero problema.

1084
00:47:32,280 --> 00:47:36,520
Nuestro verdadero problema
era que el tamaño de las

1085
00:47:36,520 --> 00:47:39,200
entradas variaba de
manera descontrolada.

1086
00:47:39,200 --> 00:47:43,840
También tratábamos a las presentaciones
como principalmente cargadas con lecturas

1087
00:47:43,840 --> 00:47:50,350
y no con escrituras, así que no
necesitábamos el rendimiento

1088
00:47:50,350 --> 00:47:51,850
en lecturas de presentaciones.

1089
00:47:51,850 --> 00:47:52,300
Claro.

1090
00:47:52,300 --> 00:47:54,440
En verdad, no las lees
tan frecuentemente, entonces.

1091
00:47:54,440 --> 00:47:55,010
Claro.

1092
00:47:55,010 --> 00:48:00,450
Como hablamos respecto al
flujo de la petición,

1093
00:48:00,450 --> 00:48:02,410
esencialmente son escrituras.

1094
00:48:02,410 --> 00:48:02,690
Sí.

1095
00:48:02,690 --> 00:48:04,880
Ni siquiera tienes que leer
la respuesta previa para

1096
00:48:04,880 --> 00:48:06,350
tomar una nueva.

1097
00:48:06,350 --> 00:48:07,090
Claro.

1098
00:48:07,090 --> 00:48:10,592
Parte de la solución aquí,
fue que denormalizamos

1099
00:48:10,592 --> 00:48:15,410
mucha de la información sobre
el progreso de un usuario a

1100
00:48:15,410 --> 00:48:16,660
través del contenido.

1101
00:48:16,660 --> 00:48:18,600

1102
00:48:18,600 --> 00:48:20,242
Eso es muy cargado en lecturas.

1103
00:48:20,242 --> 00:48:22,770
Mientras le muestras al usuario
su progreso, no necesariamente

1104
00:48:22,770 --> 00:48:26,010
tienes que recuperar todos
los documentos presentados,

1105
00:48:26,010 --> 00:48:28,460
pero sí saber si es que
el usuario ha completado

1106
00:48:28,460 --> 00:48:32,210
o no el contenido, con cuánto
alcance, ése tipo de información.

1107
00:48:32,210 --> 00:48:35,000
La podíamos desnormalizar
a otra colección.

1108
00:48:35,000 --> 00:48:35,820
OK.

1109
00:48:35,820 --> 00:48:39,546
Entonces los experimentos con
sharding señalaron que no lo

1110
00:48:39,546 --> 00:48:41,970
necesitabas después de que
se movieron a S3 y luego a

1111
00:48:41,970 --> 00:48:48,960
lo que llamamos la tercera
generación, que usa S3 para

1112
00:48:48,960 --> 00:48:49,930
esos documentos y los documentos
son mucho más compactos.

1113
00:48:49,930 --> 00:48:52,170
Y ahora que han regresado a
una situación donde usan

1114
00:48:52,170 --> 00:48:54,480
conjuntos de réplicas,
básicamente tienen un

1115
00:48:54,480 --> 00:48:58,580
solo conjunto de réplicas y
funciona lo suficientemente bien

1116
00:48:58,580 --> 00:48:59,700
para servir a todo el sistema.

1117
00:48:59,700 --> 00:49:00,080
Sí.

1118
00:49:00,080 --> 00:49:02,050
Un solo conjunto de réplicas.

1119
00:49:02,050 --> 00:49:04,920
Sí regresamos de la configuración
con "shards", como dijiste, a

1120
00:49:04,920 --> 00:49:07,600
tener un solo primario
con dos secundarios.

1121
00:49:07,600 --> 00:49:12,270
Ambos aún instancias quad,
de gran memoria en EC2.

1122
00:49:12,270 --> 00:49:17,980
Pero logramos tener nuestro
set activo en memoria sin

1123
00:49:17,980 --> 00:49:18,990
ningún problema serio.

1124
00:49:18,990 --> 00:49:22,810
No hemos necesitado configurar
una capa de cache.

1125
00:49:22,810 --> 00:49:26,730
Siempre hemos tratado de
mantener la política de

1126
00:49:26,730 --> 00:49:28,080
la solución más
simple es la mejor.

1127
00:49:28,080 --> 00:49:28,450
Sí.

1128
00:49:28,450 --> 00:49:31,580
Y para nosotros, nos ha
dado muy buen rendimiento.

1129
00:49:31,580 --> 00:49:34,050
Vamos a necesitar hacer
"shards" en algún punto.

1130
00:49:34,050 --> 00:49:35,570
Pero no ahora.

1131
00:49:35,570 --> 00:49:39,420
Y nos es claro, creo, que
la colección de presentaciones.

1132
00:49:39,420 --> 00:49:41,830
Será una de las primeras
en tener "shards".

1133
00:49:41,830 --> 00:49:45,220
Pero movernos a S3 para nosotros
en este momento, fue un triunfo

1134
00:49:45,220 --> 00:49:47,520
significativo.

1135
00:49:47,520 --> 00:49:48,490
Claro.

1136
00:49:48,490 --> 00:49:52,680
Y en términos de tu
ambiente replicado,

1137
00:49:52,680 --> 00:49:55,526
has encontrado que tienes
que estar consciente del

1138
00:49:55,526 --> 00:49:57,810
hecho que estás en un
ambiente con réplicas

1139
00:49:57,810 --> 00:50:01,720
o ha sido transparente
para el desarrollador?

1140
00:50:01,720 --> 00:50:04,480
Como mencionamos, tienes
que estar consciente, porque

1141
00:50:04,480 --> 00:50:07,625
tenemos escrituras al
primario y lecturas

1142
00:50:07,625 --> 00:50:08,060
desde el secundario.

1143
00:50:08,060 --> 00:50:09,190
Ah claro, tienes eso.

1144
00:50:09,190 --> 00:50:09,890
Tienes que estar
consciente de eso.

1145
00:50:09,890 --> 00:50:12,210
No estaba seguro si todavía
lo estaban haciendo ahora que

1146
00:50:12,210 --> 00:50:14,840
se dieron cuenta que están más
cargados de escrituras que de lecturas.

1147
00:50:14,840 --> 00:50:16,530
Así que aún continúan a enviar
las lecturas a través de los

1148
00:50:16,530 --> 00:50:17,050
secundarios.

1149
00:50:17,050 --> 00:50:18,960
Bueno, la colección de presentaciones
está cargada de escrituras.

1150
00:50:18,960 --> 00:50:21,710
La mayoría de las otras
están cargadas de lecturas.

1151
00:50:21,710 --> 00:50:22,623
Te entiendo.

1152
00:50:22,623 --> 00:50:23,470
OK.

1153
00:50:23,470 --> 00:50:24,290
Muy bien.

1154
00:50:24,290 --> 00:50:28,410
Así que tienen que estar
conscientes a ese nivel.

1155
00:50:28,410 --> 00:50:31,710
¿Ejecutan con "Safe Mode" en "true"?

1156
00:50:31,710 --> 00:50:34,070
Eso ha cambiado ahora con los
drivers más recientes, pero

1157
00:50:34,070 --> 00:50:36,020
obviamente ustedes comenzaron
mucho antes que eso.

1158
00:50:36,020 --> 00:50:36,710
Sí.

1159
00:50:36,710 --> 00:50:38,780
Si nos vamos a alejar
un poco de la colección

1160
00:50:38,780 --> 00:50:39,540
de presentaciones--

1161
00:50:39,540 --> 00:50:40,790
voy a hablar de una manera
un poco más general--

1162
00:50:40,790 --> 00:50:44,020

1163
00:50:44,020 --> 00:50:49,270
para cualquier tipo de información
de estado que el usuario

1164
00:50:49,270 --> 00:50:53,380
percibiría si es que no
persiste o desaparece,

1165
00:50:53,380 --> 00:50:54,870
definitivamente usamos "Safe Mode".

1166
00:50:54,870 --> 00:51:00,240
Para mucha de la actividad de
registros o de las escrituras

1167
00:51:00,240 --> 00:51:04,600
basadas en eventos que la
aplicación utiliza, deshabilitamos

1168
00:51:04,600 --> 00:51:07,500
el "Safe Mode" u optimizamos

1169
00:51:07,500 --> 00:51:10,130
para la velocidad de inserción.

1170
00:51:10,130 --> 00:51:10,960
Te entiendo.

1171
00:51:10,960 --> 00:51:12,090
OK.

1172
00:51:12,090 --> 00:51:15,800
Así que si es más sobre información
analítica o al por el estilo, entonces--

1173
00:51:15,800 --> 00:51:16,270
Claro.

1174
00:51:16,270 --> 00:51:18,490
Almacenamos información
adicional sobre las

1175
00:51:18,490 --> 00:51:23,200
presentaciones, como información
general sobre cómo el usuario

1176
00:51:23,200 --> 00:51:26,430
interactúa con el sitio,
a dónde va, cómo está

1177
00:51:26,430 --> 00:51:28,460
pasando el tiempo.

1178
00:51:28,460 --> 00:51:30,220
También guardamos
mucho de eso en Mongo.

1179
00:51:30,220 --> 00:51:32,730

1180
00:51:32,730 --> 00:51:36,040
Pero, mayormente usamos
los drivers para eso y

1181
00:51:36,040 --> 00:51:42,690
somos muy específicos sobre
nuestra estrategia de inserción

1182
00:51:42,690 --> 00:51:44,160
respecto a ese tipo
de información.

1183
00:51:44,160 --> 00:51:44,990
Claro.

1184
00:51:44,990 --> 00:51:47,400
Entonces hay que hablar un poco
sobre escalar y la manera en que

1185
00:51:47,400 --> 00:51:50,950
hacen planeamiento de capacidad
y otros cosas de esa naturaleza.

1186
00:51:50,950 --> 00:51:54,670
Primeramente, dijiste que
están ejecutando en un 4x grande.

1187
00:51:54,670 --> 00:51:55,685
¿También para tus réplicas?

1188
00:51:55,685 --> 00:51:58,090
¿Son todas máquinas iguales?

1189
00:51:58,090 --> 00:51:59,580
Los primarios y secundarios están en

1190
00:51:59,580 --> 00:52:00,675
el mismo tipo de instancia en EC2.

1191
00:52:00,675 --> 00:52:01,170
Mismo tipo de instancia.

1192
00:52:01,170 --> 00:52:02,440
Sí.

1193
00:52:02,440 --> 00:52:03,660
OK.

1194
00:52:03,660 --> 00:52:07,500
Y si quieres agregar
más capacida, ¿cómo

1195
00:52:07,500 --> 00:52:09,210
lo haces?

1196
00:52:09,210 --> 00:52:14,070
So siempre fueron
"quads" extra grandes.

1197
00:52:14,070 --> 00:52:16,876
Tuvimos que hacer una mejora
y queríamos hacerla de tal

1198
00:52:16,876 --> 00:52:18,670
manera que no tengamos
ningún tiempo inactivo.

1199
00:52:18,670 --> 00:52:23,270
Para hacer eso, Mongo te permite
cambiar a una configuración

1200
00:52:23,270 --> 00:52:27,570
de conjunto de réplicas, pero
sí tienes que, esencialmente,

1201
00:52:27,570 --> 00:52:31,160
apagar el sitio y apagar la
base de datos por lo menos

1202
00:52:31,160 --> 00:52:32,260
por un breve momento.

1203
00:52:32,260 --> 00:52:34,720
Así que cuando cambiamos
de una sola instancia a

1204
00:52:34,720 --> 00:52:37,980
una configuración de conjunto de
réplicas sí apagamos el sitio.

1205
00:52:37,980 --> 00:52:42,300
Entre tener la configuración
de réplicas y querer actualizar

1206
00:52:42,300 --> 00:52:44,490
las máquinas, lo que hicimos es 

1207
00:52:44,490 --> 00:52:49,800
agregar una instancia abastecida
más grande como un secundario y

1208
00:52:49,800 --> 00:52:54,770
hacer que esa instancia sea
puesta al día a través de

1209
00:52:54,770 --> 00:52:57,560
la replicación del conjunto.

1210
00:52:57,560 --> 00:53:02,680
Una vez que estuvo sincronizada
degradamos el primario y pusimos

1211
00:53:02,680 --> 00:53:05,350
la señal de prioridad en
la nueva instancia del

1212
00:53:05,350 --> 00:53:09,540
secundario para que
asuma la responsabilidad

1213
00:53:09,540 --> 00:53:10,170
de ser primario.

1214
00:53:10,170 --> 00:53:12,630
Ocurrió sin interrupciones en verdad.

1215
00:53:12,630 --> 00:53:14,630
Sí.

1216
00:53:14,630 --> 00:53:16,225
Y sin mucho tiempo
de inactividad.

1217
00:53:16,225 --> 00:53:19,000
Podría potencialmente tener ningún
tiempo inactivo excepto por el

1218
00:53:19,000 --> 00:53:21,470
momento en que estás haciendo
la transición y cuando degradas

1219
00:53:21,470 --> 00:53:24,220
al primario para
promover al secundario.

1220
00:53:24,220 --> 00:53:24,710
Sí.

1221
00:53:24,710 --> 00:53:26,810
Y si eres paciente, creo.

1222
00:53:26,810 --> 00:53:29,600
Es de seguro más rápido a
veces apagar el sitio,

1223
00:53:29,600 --> 00:53:33,930
y si tienes almacén EBS,
desmontarlo de una instancia

1224
00:53:33,930 --> 00:53:37,110
y remontarlo en otra.

1225
00:53:37,110 --> 00:53:39,345
Sí estás apurado, ésa
es la opción rápida.

1226
00:53:39,345 --> 00:53:44,060
Pero si no estás apurado y lo
has planeado correctamente

1227
00:53:44,060 --> 00:53:46,970
y ves la tendencia o la
señal de advertencia,

1228
00:53:46,970 --> 00:53:50,100
pues entonces, sí, puedes,
potencialmente, expandir

1229
00:53:50,100 --> 00:53:51,850
tu capacidad sin
tiempo de inactividad.

1230
00:53:51,850 --> 00:53:52,650
Claro.

1231
00:53:52,650 --> 00:53:57,930
Entonces, apagar el servidor
y montar el almacén EBS a una

1232
00:53:57,930 --> 00:54:02,630
nueva máquina resulta en
más tiempo de baja pero en

1233
00:54:02,630 --> 00:54:04,610
menos tiempo desde el momento
en que tomas la decisión de

1234
00:54:04,610 --> 00:54:06,330
hacer esto y el momento
en que tienes la nueva máquina.

1235
00:54:06,330 --> 00:54:06,680
Sí.

1236
00:54:06,680 --> 00:54:11,050
La replicación, especialmente
para un conjunto de datos que

1237
00:54:11,050 --> 00:54:13,570
tiene un tamaño significativo,
puede tomar mucho tiempo.

1238
00:54:13,570 --> 00:54:14,900
Puede tomar horas.

1239
00:54:14,900 --> 00:54:17,270
¿Copias los archivos primero
y luego haces la replicación

1240
00:54:17,270 --> 00:54:19,460
o dejas que la replicación
haga todo el proceso

1241
00:54:19,460 --> 00:54:20,090
de sincronizar?

1242
00:54:20,090 --> 00:54:22,310
Hemos hecho ambos.

1243
00:54:22,310 --> 00:54:25,580
Hemos tratado de sincronizar
a través del ancho de banda

1244
00:54:25,580 --> 00:54:26,660
de la red, o de las escritura.

1245
00:54:26,660 --> 00:54:29,400
Si tienes IOPS abastecido,
es mucho mejor.

1246
00:54:29,400 --> 00:54:32,600
Si estás replicando a través
de instancias abastecidas IOPS

1247
00:54:32,600 --> 00:54:35,160
de una a otra, es, por supuesto,
mucho, mucho más rápido que

1248
00:54:35,160 --> 00:54:38,850
si vas de un EBS estándar o una
instancia de almacén efímero 

1249
00:54:38,850 --> 00:54:42,040
de soporte a una IOPS abastecida,
o cualquier otro tipo de instancia.

1250
00:54:42,040 --> 00:54:46,710
Pero si ambas son
abastecidas, puede

1251
00:54:46,710 --> 00:54:47,850
tener buen rendimiento.

1252
00:54:47,850 --> 00:54:51,390
Es de seguro más fácil simplemente
conectar un miembro completamente

1253
00:54:51,390 --> 00:54:55,220
fresco al conjunto de réplicas
y dejar que sincronice.

1254
00:54:55,220 --> 00:54:58,030
A veces tienes que reiniciarlo,

1255
00:54:58,030 --> 00:54:59,030
pero casi siempre se sincroniza.

1256
00:54:59,030 --> 00:55:04,700
Y en términos de obtener
la performance que necesitas,

1257
00:55:04,700 --> 00:55:09,290
¿me decías que ejecutas algo
del "front end" en Heroku?

1258
00:55:09,290 --> 00:55:12,380
Y el "back end"
siempre está en AWS.

1259
00:55:12,380 --> 00:55:14,370
¿Es un desafío?

1260
00:55:14,370 --> 00:55:19,000
¿Tiene que estar el desarrollador
consciente de la mayor latencia

1261
00:55:19,000 --> 00:55:20,662
que digamos si es que
lo ejecutas localmente?

1262
00:55:20,662 --> 00:55:22,860
¿Tienen que estar más
conscientes del costo

1263
00:55:22,860 --> 00:55:25,210
de hablarle a una base de datos
que no está necesariamente conectada

1264
00:55:25,210 --> 00:55:27,660
en el mismo LAN o algo así?

1265
00:55:27,660 --> 00:55:30,995
Entonces si es que retornamos a
nuestro cliente, nuestra aplicación

1266
00:55:30,995 --> 00:55:37,070
y nuestro API, nuestra capa
de aplicación y nuestra capa

1267
00:55:37,070 --> 00:55:42,095
de API, que esencialmente
envuelven o manejan todas

1268
00:55:42,095 --> 00:55:44,840
las lecturas y escrituras
a la base de datos, ambos

1269
00:55:44,840 --> 00:55:46,620
están en Heroku.

1270
00:55:46,620 --> 00:55:51,980
Y Heroku también está en AWS.

1271
00:55:51,980 --> 00:55:53,230
Claro, ellos usan AWS.

1272
00:55:53,230 --> 00:55:55,530
Sus dínamos corren sobre AWS--

1273
00:55:55,530 --> 00:55:57,990
al menos eso es
lo que he oído.

1274
00:55:57,990 --> 00:56:03,810
Y estoy casi seguro que
usamos, en términos de

1275
00:56:03,810 --> 00:56:04,800
la zona de disponibilidad--

1276
00:56:04,800 --> 00:56:07,660
AWS tiene diferentes
zonas de disponibilidad

1277
00:56:07,660 --> 00:56:08,890
por todo el mundo.

1278
00:56:08,890 --> 00:56:12,510
Y por supuestom cuando
atraviesas una red,

1279
00:56:12,510 --> 00:56:16,590
te importa la latencia
entre los nodos.

1280
00:56:16,590 --> 00:56:20,200
Y si estás al otro lado
del mundo, vas a tener

1281
00:56:20,200 --> 00:56:22,340
latencia más significativa
que si ambas máquinas están

1282
00:56:22,340 --> 00:56:25,810
conectadas, asumiendo que
tienes conexiones fantásticas

1283
00:56:25,810 --> 00:56:26,830
entre ellas.

1284
00:56:26,830 --> 00:56:32,690
Y tanto nosotros
como Heroku estamos

1285
00:56:32,690 --> 00:56:34,070
en la misma zona.

1286
00:56:34,070 --> 00:56:37,775
Y por eso, hay menos
latencia que si estuviéramos

1287
00:56:37,775 --> 00:56:39,500
en diferentes zonas.

1288
00:56:39,500 --> 00:56:41,960
Pero igual atravesamos la red.

1289
00:56:41,960 --> 00:56:44,810
Así que cuando tienes
una aplicación que está

1290
00:56:44,810 --> 00:56:46,380
comunicándose con la
base de datos y no

1291
00:56:46,380 --> 00:56:49,310
están en la misma caja,
van a tener que atravesar

1292
00:56:49,310 --> 00:56:51,320
la red y tienes que lidiar con
un tipo de latencia u otro.

1293
00:56:51,320 --> 00:56:53,870
Como resultado, vas a tener
que estar bien consciente de

1294
00:56:53,870 --> 00:56:55,590
el número de peticiones--

1295
00:56:55,590 --> 00:56:57,120
no sólo el tipo de consultas
sino el número bruto de

1296
00:56:57,120 --> 00:56:58,460
consultas--

1297
00:56:58,460 --> 00:57:00,370
que le estás haciendo
a la base de datos.

1298
00:57:00,370 --> 00:57:03,560
Porque hay un gasto general
de comunicación simplemente

1299
00:57:03,560 --> 00:57:06,060
para llegar a la base de datos
y enviar la respuesta a

1300
00:57:06,060 --> 00:57:06,660
la aplicación.

1301
00:57:06,660 --> 00:57:10,180
Así que para nosotros, tratamos
de asegurarnos que cada petición

1302
00:57:10,180 --> 00:57:15,030
involucre un cierto número de
peticiones a la base de datos

1303
00:57:15,030 --> 00:57:17,360
o menos. Para nosotros ése
número es más o menos 10.

1304
00:57:17,360 --> 00:57:23,260
Hasta eso es un poco generoso.

1305
00:57:23,260 --> 00:57:23,780
Sí.

1306
00:57:23,780 --> 00:57:28,460
Es interesante, porque soy
un tipo un poco mayor, pero

1307
00:57:28,460 --> 00:57:34,390
en los noventas y a principio
de los 2000, cuando creabas

1308
00:57:34,390 --> 00:57:37,180
un sistema basado en una base
de datos relacional, la primera

1309
00:57:37,180 --> 00:57:39,890
regla era que nunca le
adjuntabas el servidor

1310
00:57:39,890 --> 00:57:42,960
web a la base de datos
porque sería muy lento.

1311
00:57:42,960 --> 00:57:44,800
Y usabas el cache.

1312
00:57:44,800 --> 00:57:48,020
Y creo que para mí, una de las
cosas interesantes sobre MongoDB

1313
00:57:48,020 --> 00:57:52,770
es que ahora cuando adjuntas los
servidores web directamente a la

1314
00:57:52,770 --> 00:57:55,050
base de datos y no tienes una
capa separada de cache y aún

1315
00:57:55,050 --> 00:57:58,700
así obtienes rendimiento
eficiente para los usuarios.

1316
00:57:58,700 --> 00:58:00,850
Eso es interesante.

1317
00:58:00,850 --> 00:58:04,240
Pero ahora creo que estamos
virtualizando todo y no es

1318
00:58:04,240 --> 00:58:07,150
siempre en el mismo sitio,
está volviéndose más difícil

1319
00:58:07,150 --> 00:58:09,820
porque obtenemos más latencia.

1320
00:58:09,820 --> 00:58:12,180
Sí. Nos hemos movido a la nube,
así que ahora es más fácil

1321
00:58:12,180 --> 00:58:14,030
proveer y escalar horizontalmente.

1322
00:58:14,030 --> 00:58:17,050
Pero hemos introducido mucha
latencia entre conexiones.

1323
00:58:17,050 --> 00:58:19,810
Y como resultado, de todas maneras
tienes que estar muy consciente de

1324
00:58:19,810 --> 00:58:21,730
el volumen de peticiones.

1325
00:58:21,730 --> 00:58:24,050
Así que tienes que
agrupar tus peticiones.

1326
00:58:24,050 --> 00:58:25,030
Tienes que ser muy
consciente de ello.

1327
00:58:25,030 --> 00:58:25,350
Claro.

1328
00:58:25,350 --> 00:58:28,200
Y ni siquiera es un problema con
el rendimiento, sino la latencia.

1329
00:58:28,200 --> 00:58:30,940
No es que no puedas procesar
suficientes peticiones en el

1330
00:58:30,940 --> 00:58:34,750
servidor, es que cualquier usuario
que está haciendo algo en una página

1331
00:58:34,750 --> 00:58:38,970
web, no puedes esperar mucho
ida y vuelta sobre la red

1332
00:58:38,970 --> 00:58:40,585
o va a ser muy lento para ellos.

1333
00:58:40,585 --> 00:58:41,080
Sí, es un buen punto.

1334
00:58:41,080 --> 00:58:43,580
Así que por eso quieres
hacer peticiones asíncronas

1335
00:58:43,580 --> 00:58:47,530
si es posible o que no
tengan, por lo menos,

1336
00:58:47,530 --> 00:58:49,240
que ser secuenciales.

1337
00:58:49,240 --> 00:58:50,970
Claro.

1338
00:58:50,970 --> 00:58:51,530
Muy bien.

1339
00:58:51,530 --> 00:58:57,330
Bueno, gracias por presentarnos
los temas internos de Codecademy

1340
00:58:57,330 --> 00:58:59,110
y explicarnos cómo funciona.

1341
00:58:59,110 --> 00:59:01,020
Ha sido fantástico así
que muchas gracias.

1342
00:59:01,020 --> 00:59:01,390
Gracias.

1343
00:59:01,390 --> 00:59:02,610
Fue un ejercicio muy divertido.

1344
00:59:02,610 --> 00:59:02,680
Muy bien.

1345
00:59:02,680 --> 00:59:03,930
Fue muy bueno.

1346
00:59:03,930 --> 00:59:04,300